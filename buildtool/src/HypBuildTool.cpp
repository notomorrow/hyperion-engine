#include <core/cli/CommandLine.hpp>

#include <core/logging/Logger.hpp>

#include <core/filesystem/FilePath.hpp>

#include <core/threading/Thread.hpp>
#include <core/threading/Scheduler.hpp>
#include <core/threading/AtomicVar.hpp>
#include <core/threading/TaskSystem.hpp>
#include <core/threading/TaskThread.hpp>
#include <core/threading/Mutex.hpp>

#include <core/io/ByteWriter.hpp>

#include <core/functional/Proc.hpp>

#include <core/memory/UniquePtr.hpp>

#include <generator/generators/CXXModuleGenerator.hpp>
#include <generator/generators/CSharpModuleGenerator.hpp>

#include <parser/Parser.hpp>

#include <analyzer/Analyzer.hpp>

#if !defined(HYP_BUILD_TOOL_VERSION_MAJOR) || !defined(HYP_BUILD_TOOL_VERSION_MINOR) || !defined(HYP_BUILD_TOOL_VERSION_PATCH)
#error "HYP_BUILD_TOOL_VERSION_MAJOR, HYP_BUILD_TOOL_VERSION_MINOR, and HYP_BUILD_TOOL_VERSION_PATCH must be defined"
#endif

namespace hyperion {
namespace buildtool {

HYP_DEFINE_LOG_CHANNEL(BuildTool);

static constexpr bool g_cxxUnityBuildEnabled = true;
static constexpr uint32 g_cxxUnityBuildIdealFileSize = 64 * 1024;

class WorkerThread : public TaskThread
{
public:
    WorkerThread(ThreadId id)
        : TaskThread(id)
    {
    }

    virtual ~WorkerThread() override = default;
};

class WorkerThreadPool : public TaskThreadPool
{
public:
    WorkerThreadPool()
        : TaskThreadPool(TypeWrapper<WorkerThread>(), "BuildTool_WorkerThread", 4)
    {
    }

    virtual ~WorkerThreadPool() override = default;
};

class HypBuildTool
{
public:
    HypBuildTool(
        const FilePath& workingDirectory,
        const FilePath& sourceDirectory,
        const FilePath& cxxOutputDirectory,
        const FilePath& csharpOutputDirectory,
        const HashSet<FilePath>& excludeDirectories,
        const HashSet<FilePath>& excludeFiles)
    {
        m_analyzer.SetWorkingDirectory(workingDirectory);
        m_analyzer.SetSourceDirectory(sourceDirectory);
        m_analyzer.SetCXXOutputDirectory(cxxOutputDirectory);
        m_analyzer.SetCSharpOutputDirectory(csharpOutputDirectory);

        m_analyzer.SetExcludeDirectories(excludeDirectories);
        m_analyzer.SetExcludeFiles(excludeFiles);

        m_analyzer.SetGlobalDefines(GetGlobalDefines());
        m_analyzer.SetIncludePaths(GetIncludePaths());

        m_threadPool.Start();
    }

    ~HypBuildTool()
    {
        m_threadPool.Stop();
    }

    Result Run()
    {
        FindModules();

        Task processModules = ProcessModules();
        WaitWhileTaskRunning(processModules);

        Task buildClassTree = BuildClassTree();
        WaitWhileTaskRunning(buildClassTree);

        Task generateOutputFiles = GenerateOutputFiles();
        WaitWhileTaskRunning(generateOutputFiles);

        if (m_analyzer.GetState().HasErrors())
        {
            for (const AnalyzerError& error : m_analyzer.GetState().errors)
            {
                HYP_LOG(BuildTool, Error, "Error: {}", error.GetMessage());
            }

            return HYP_MAKE_ERROR(Error, "Build tool finished with errors");
        }

        // finally, add BuildToolOutput.inc to the output directory
        FilePath outputFilePath = m_analyzer.GetCXXOutputDirectory() / "BuildToolOutput.inc";
        FileByteWriter outputFileWriter(outputFilePath);
        if (!outputFileWriter.IsOpen())
        {
            return HYP_MAKE_ERROR(Error, "Failed to open output file: {}", outputFilePath);
        }

        // for parsing from scripts to enable rebuild triggering:
        outputFileWriter.WriteString("//! VERSION " + String::ToString(HYP_BUILD_TOOL_VERSION_MAJOR) + "." +
                                      String::ToString(HYP_BUILD_TOOL_VERSION_MINOR) + "." +
                                      String::ToString(HYP_BUILD_TOOL_VERSION_PATCH) + "\n\n");
        outputFileWriter.WriteString("// Copyright (c) No Tomorrow Games\n");
        outputFileWriter.WriteString("// This file is generated by the HypBuildTool. Do not edit manually.\n\n");
        outputFileWriter.WriteString("#pragma once\n\n");
        outputFileWriter.WriteString("#define HYP_BUILDTOOL_TIMESTAMP " + String::ToString(Time::Now().ToMilliseconds()) + "\n\n");
        outputFileWriter.WriteString("#define HYP_BUILD_TOOL_VERSION_MAJOR " + String::ToString(HYP_BUILD_TOOL_VERSION_MAJOR) + "\n");
        outputFileWriter.WriteString("#define HYP_BUILD_TOOL_VERSION_MINOR " + String::ToString(HYP_BUILD_TOOL_VERSION_MINOR) + "\n");
        outputFileWriter.WriteString("#define HYP_BUILD_TOOL_VERSION_PATCH " + String::ToString(HYP_BUILD_TOOL_VERSION_PATCH) + "\n\n");

        outputFileWriter.WriteString("\n");
        outputFileWriter.Close();

        return {};
    }

private:
    HashMap<String, String> GetGlobalDefines() const
    {
        return {
            { "HYP_BUILDTOOL", "1" },
            { "HYP_VULKAN", "1" },
            { "HYP_CLASS(...)", "" },
            { "HYP_STRUCT(...)", "" },
            { "HYP_ENUM(...)", "" },
            { "HYP_FIELD(...)", "" },
            { "HYP_METHOD(...)", "" },
            { "HYP_PROPERTY(...)", "" },
            { "HYP_OBJECT_BODY(...)", "" },
            { "HYP_API", "" },
            { "HYP_EXPORT", "" },
            { "HYP_IMPORT", "" },
            { "HYP_FORCE_INLINE", "inline" },
            { "HYP_NODISCARD", "" }
        };
    }

    HashSet<String> GetIncludePaths() const
    {
        const FilePath& workingDirectory = m_analyzer.GetWorkingDirectory();

        return {
            workingDirectory / "src",
            workingDirectory / "include"
        };
    }

    void FindModules()
    {
        Proc<void(const FilePath&)> iterateFilesAndSubdirectories;

        iterateFilesAndSubdirectories = [&](const FilePath& dir)
        {
            for (const String& excludeDir : m_analyzer.GetExcludeDirectories())
            {
                const FilePath relativePath = FilePath(FileSystem::RelativePath(dir.Data(), m_analyzer.GetSourceDirectory().Data()).c_str());

                if (relativePath.StartsWith(excludeDir))
                {
                    return;
                }
            }

            Array<Module*> localModules;

            for (const FilePath& file : dir.GetAllFilesInDirectory())
            {
                if (file.EndsWith(".hpp"))
                {
                    const FilePath relativePath = FilePath(FileSystem::RelativePath(file.Data(), m_analyzer.GetSourceDirectory().Data()).c_str());

                    if (m_analyzer.GetExcludeFiles().Contains(relativePath))
                    {
                        continue;
                    }

                    localModules.PushBack(m_analyzer.AddModule(file));
                }
            }

            Array<FilePath> localSubdirectories = dir.GetSubdirectories();

            if (localSubdirectories.Empty())
            {
                return;
            }

            for (const FilePath& subdirectory : localSubdirectories)
            {
                iterateFilesAndSubdirectories(subdirectory);
            }
        };

        iterateFilesAndSubdirectories(m_analyzer.GetSourceDirectory());
    }

    Task<void> ProcessModules()
    {
        Task<void> task;

        TaskBatch* batch = new TaskBatch();
        batch->pool = &m_threadPool;
        batch->OnComplete
            .Bind([batch, promise = task.Promise()]()
                {
                    promise->Fulfill();

                    DeferDeleteTaskBatch(batch);
                })
            .Detach();

        for (const UniquePtr<Module>& mod : m_analyzer.GetModules())
        {
            batch->AddTask([this, mod = mod.Get()]()
                {
                    auto result = m_analyzer.ProcessModule(*mod);

                    if (result.HasError())
                    {
                        m_analyzer.AddError(result.GetError());

                        return;
                    }
                });
        }

        TaskSystem::GetInstance().EnqueueBatch(batch);

        return task;
    }

    Task<void> BuildClassTree()
    {
        return TaskSystem::GetInstance().Enqueue([this]()
            {
                Array<HypClassDefinition*> hypClassDefinitions;
                HashMap<String, uint32> hypClassDefinitionIds;

                for (const UniquePtr<Module>& mod : m_analyzer.GetModules())
                {
                    for (auto& it : mod->GetHypClasses())
                    {
                        if (hypClassDefinitionIds.Contains(it.second.name))
                        {
                            m_analyzer.AddError(HYP_MAKE_ERROR(AnalyzerError, "Duplicate HypClassDefinition name found: {}", mod->GetPath(), 0, it.second.name));

                            continue;
                        }

                        Assert(it.second.staticIndex == -1);
                        Assert(it.second.numDescendants == 0);

                        const uint32 hypClassDefinitionId = uint32(hypClassDefinitions.Size());

                        hypClassDefinitionIds[it.second.name] = hypClassDefinitionId;

                        hypClassDefinitions.PushBack(&it.second);
                    }
                }

                Array<Array<uint32>, DynamicAllocator> derived;
                derived.Resize(hypClassDefinitions.Size());

                for (const HypClassDefinition* hypClassDefinition : hypClassDefinitions)
                {
                    const uint32 child = hypClassDefinitionIds.At(hypClassDefinition->name);

                    for (const String& baseClassName : hypClassDefinition->baseClassNames)
                    {
                        const auto parentIt = hypClassDefinitionIds.Find(baseClassName);

                        if (parentIt == hypClassDefinitionIds.End())
                        {
                            continue;
                        }

                        const uint32 parent = parentIt->second;
                        Assert(parent < hypClassDefinitions.Size());

                        derived[parent].PushBack(child);
                    }
                }

                Array<uint32> indeg;
                indeg.Resize(hypClassDefinitions.Size());

                for (const Array<uint32>& children : derived)
                {
                    for (uint32 child : children)
                    {
                        indeg[child]++;
                    }
                }

                Array<uint32> roots;

                for (SizeType i = 0; i < indeg.Size(); i++)
                {
                    if (indeg[i] == 0)
                    {
                        roots.PushBack(i);
                    }
                }

                Array<uint32> stack;
                stack.Reserve(hypClassDefinitions.Size());

                uint32 nextOut = 0;

                Proc<void(uint32)> TopologicalSort;
                TopologicalSort = [&](uint32 id)
                {
                    Assert(id < hypClassDefinitions.Size());

                    HypClassDefinition* hypClassDefinition = hypClassDefinitions[id];

                    uint32 start = nextOut;

                    hypClassDefinition->staticIndex = int(nextOut++);

                    stack.PushBack(id);

                    for (uint32 child : derived[id])
                    {
                        if (hypClassDefinitions[child]->staticIndex == -1)
                        {
                            TopologicalSort(child);
                        }
                    }

                    stack.PopBack();

                    hypClassDefinition->numDescendants = nextOut - start - 1;
                    hypClassDefinition->staticIndex = int(start + 1);
                };

                for (uint32 root : roots)
                {
                    TopologicalSort(root);
                }

                // Log out the class hierarchy with static indices
                for (const HypClassDefinition* hypClassDefinition : hypClassDefinitions)
                {
                    HYP_LOG(BuildTool, Info, "Class: {}, Type: {}, Static Index: {}, Num Descendants: {}, Parent: {}",
                        hypClassDefinition->name,
                        HypClassDefinitionTypeToString(hypClassDefinition->type),
                        hypClassDefinition->staticIndex,
                        hypClassDefinition->numDescendants,
                        String::Join(hypClassDefinition->baseClassNames, ", "));
                }
            });
    }

    Task<void> GenerateOutputFiles()
    {
        Assert(m_analyzer.GetCXXOutputDirectory().MkDir(), "Failed to create C++ output directory: {}", m_analyzer.GetCXXOutputDirectory());
        Assert(m_analyzer.GetCSharpOutputDirectory().MkDir(), "Failed to create C# output directory: {}", m_analyzer.GetCSharpOutputDirectory());

        Task<void> task;

        TaskBatch* batch = new TaskBatch();
        batch->pool = &m_threadPool;
        batch->OnComplete
            .Bind([batch, promise = task.Promise()]()
                {
                    promise->Fulfill();

                    DeferDeleteTaskBatch(batch);
                })
            .Detach();

        RC<CSharpModuleGenerator> csharpModuleGenerator = MakeRefCountedPtr<CSharpModuleGenerator>();

        for (const UniquePtr<Module>& mod : m_analyzer.GetModules())
        {
            if (mod->GetHypClasses().Empty())
            {
                continue;
            }

            // csharp modules can be processed async from C++ modules
            batch->AddTask([this, csharpModuleGenerator, &mod = *mod]()
                {
                    if (Result res = csharpModuleGenerator->Generate(m_analyzer, mod); res.HasError())
                    {
                        m_analyzer.AddError(AnalyzerError(res.GetError(), mod.GetPath()));
                    }
                });
        }

        RC<CXXModuleGenerator> cxxModuleGenerator = MakeRefCountedPtr<CXXModuleGenerator>();

        static constexpr uint32 idealCxxModuleFileSize = g_cxxUnityBuildEnabled ? g_cxxUnityBuildIdealFileSize : 1;

        uint32 fileIndex = 0;
        char filenameBuffer[256] = {};

        FileByteWriter* cxxModuleWriter = nullptr;

        auto toLetters = [](uint32 idx, char* dst, SizeType cap)
        {
            char buf[32];
            SizeType n = 0;

            ++idx;
            while (idx)
            {
                uint32 r = (idx - 1) % 26;
                buf[n++] = char('A' + r);
                idx = (idx - 1) / 26;
            }

            if (n + 4 >= cap)
            {
                return false;
            }

            for (SizeType i = 0; i < n; ++i)
            {
                dst[i] = buf[n - 1 - i];
            }

            dst[n] = '\0';

            return true;
        };

        auto updateFilenameBuffer = [&]()
        {
            Assert(toLetters(fileIndex, filenameBuffer, sizeof(filenameBuffer)));

            std::strcat(filenameBuffer, ".cpp");

            ++fileIndex;
        };

        for (const UniquePtr<Module>& mod : m_analyzer.GetModules())
        {
            if (mod->GetHypClasses().Empty())
            {
                continue;
            }

            if (!cxxModuleWriter || cxxModuleWriter->Position() >= idealCxxModuleFileSize)
            {
                if (cxxModuleWriter)
                {
                    cxxModuleWriter->Close();
                    delete cxxModuleWriter;
                }

                updateFilenameBuffer();

                cxxModuleWriter = new FileByteWriter(m_analyzer.GetCXXOutputDirectory() / filenameBuffer);

                // add main required header that is shared across all generated modules.
                cxxModuleWriter->WriteString("#include <core/object/HypClassUtils.hpp>\n");
            }

            if (Result res = cxxModuleGenerator->Generate(m_analyzer, *mod, *cxxModuleWriter); res.HasError())
            {
                m_analyzer.AddError(AnalyzerError(res.GetError(), mod->GetPath()));
            }
        }

        if (cxxModuleWriter != nullptr)
        {
            cxxModuleWriter->Close();
            delete cxxModuleWriter;
        }

        TaskSystem::GetInstance().EnqueueBatch(batch);

        return task;
    }

    void LogGeneratedClasses() const
    {
        for (const UniquePtr<Module>& mod : m_analyzer.GetModules())
        {
            for (const Pair<String, HypClassDefinition>& hypClass : mod->GetHypClasses())
            {
                HYP_LOG(BuildTool, Info, "Class: {}", hypClass.first);

                // Log out all members
                for (const HypMemberDefinition& hypMember : hypClass.second.members)
                {
                    if (!hypMember.cxxType)
                    {
                        continue;
                    }

                    json::JSONValue json;
                    hypMember.cxxType->ToJSON(json);

                    HYP_LOG(BuildTool, Info, "\tMember: {}\t{}", hypMember.name, json.ToString(true));
                }
            }
        }
    }

    void WaitWhileTaskRunning(const Task<void>& task)
    {
        Threads::AssertOnThread(g_mainThread);

        Assert(task.IsValid());

        while (!task.IsCompleted())
        {
            Threads::Sleep(100);
        }
    }

    // Setup a task to delete the batch
    // Use when deleting the batch inline would cause an issue due to destructing a mutex that is currently locked.
    static void DeferDeleteTaskBatch(TaskBatch* batch)
    {
        if (!batch)
        {
            return;
        }

        TaskSystem::GetInstance().Enqueue([batch]()
            {
                delete batch;
            },
            TaskThreadPoolName::THREAD_POOL_BACKGROUND, TaskEnqueueFlags::FIRE_AND_FORGET);
    }

    WorkerThreadPool m_threadPool;
    Analyzer m_analyzer;
};

} // namespace buildtool
} // namespace hyperion

using namespace hyperion;
using namespace buildtool;

int main(int argc, char** argv)
{
    Threads::SetCurrentThreadId(g_mainThread);

    LogChannelRegistrar::GetInstance().RegisterAll();

    static const CommandLineArgumentDefinitions definitions = []()
    {
        CommandLineArgumentDefinitions result;
        result.Add("WorkingDirectory", "", "", CommandLineArgumentFlags::REQUIRED, CommandLineArgumentType::STRING);
        result.Add("SourceDirectory", "", "", CommandLineArgumentFlags::REQUIRED, CommandLineArgumentType::STRING);
        result.Add("CXXOutputDirectory", "", "", CommandLineArgumentFlags::REQUIRED, CommandLineArgumentType::STRING);
        result.Add("CSharpOutputDirectory", "", "", CommandLineArgumentFlags::REQUIRED, CommandLineArgumentType::STRING);
        result.Add("ExcludeDirectories", "", "", CommandLineArgumentFlags::NONE, CommandLineArgumentType::STRING);
        result.Add("ExcludeFiles", "", "", CommandLineArgumentFlags::NONE, CommandLineArgumentType::STRING);
        result.Add("Mode", "m", "", CommandLineArgumentFlags::NONE, Array<String> { "ParseHeaders" }, String("ParseHeaders"));

        return result;
    }();

    CommandLineParser commandLineParser { &definitions };

    if (auto parseResult = commandLineParser.Parse(argc, argv))
    {
        TaskSystem::GetInstance().Start();

        const FilePath workingDirectory = FilePath(parseResult.GetValue()["WorkingDirectory"].AsString());

        if (!workingDirectory.IsDirectory())
        {
            HYP_LOG(BuildTool, Error, "Working directory is not a directory: {}", workingDirectory);

            return 1;
        }

        const FilePath sourceDirectory = FilePath(parseResult.GetValue()["SourceDirectory"].AsString());

        if (!sourceDirectory.IsDirectory())
        {
            HYP_LOG(BuildTool, Error, "Source directory is not a directory: {}", sourceDirectory);

            return 1;
        }

        const FilePath cxxOutputDirectory = FilePath(parseResult.GetValue()["CXXOutputDirectory"].AsString());
        const FilePath csharpOutputDirectory = FilePath(parseResult.GetValue()["CSharpOutputDirectory"].AsString());

        HashSet<FilePath> excludeDirectories;
        HashSet<FilePath> excludeFiles;

        if (parseResult.GetValue().Contains("ExcludeDirectories"))
        {
            const json::JSONArray excludeDirectoriesJson = parseResult.GetValue()["ExcludeDirectories"].ToArray();

            for (const json::JSONValue& value : excludeDirectoriesJson)
            {
                excludeDirectories.Insert(FilePath(FileSystem::RelativePath(value.ToString().Data(), sourceDirectory.Data()).c_str()));
            }
        }

        if (parseResult.GetValue().Contains("ExcludeFiles"))
        {
            const json::JSONArray excludeFilesJson = parseResult.GetValue()["ExcludeFiles"].ToArray();

            for (const json::JSONValue& value : excludeFilesJson)
            {
                excludeFiles.Insert(FilePath(FileSystem::RelativePath(value.ToString().Data(), sourceDirectory.Data()).c_str()));
            }
        }

        buildtool::HypBuildTool buildTool {
            workingDirectory,
            sourceDirectory,
            cxxOutputDirectory,
            csharpOutputDirectory,
            excludeDirectories,
            excludeFiles
        };

        Result res = buildTool.Run();

        TaskSystem::GetInstance().Stop();

        if (res.HasError())
        {
            return 1;
        }
    }
    else
    {
        HYP_LOG(BuildTool, Error, "Failed to parse arguments!\n\t{}", parseResult.GetError().GetMessage());

        return 1;
    }

    return 0;
}
