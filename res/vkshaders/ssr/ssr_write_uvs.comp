#version 450
#extension GL_GOOGLE_include_directive : require

#include "ssr_header.inc"

layout(set = 0, binding = 0, rgba16f) uniform writeonly image2D ssr_uvs;

#include "../include/Temporal.glsl"

#define SSR_JITTER_OFFSET 0.0
#define MAX_ROUGHNESS 0.75

vec2 scene_resolution = vec2(ssr_params.dimension);

bool TraceRays(
    vec3 ray_origin,
    vec3 ray_direction,
    out vec2 hit_pixel,
    out vec3 hit_point,
    out float hit_weight,
    out float num_iterations
)
{
    bool intersect = false;
    num_iterations = 0.0;
    hit_weight = 0.0;

    vec3 ray_step = ssr_params.ray_step * normalize(ray_direction);
    vec3 marching_position = ray_origin;
    float depth_from_screen;
    float step_delta;

    const mat4 inverse_proj = inverse(scene.projection);

    int i = 0;

    for (; i < ssr_params.num_iterations; i++) {
        marching_position += ray_step;

        hit_pixel = GetProjectedPositionFromView(scene.projection, marching_position);

        float depth = SampleDepth(hit_pixel);

        depth_from_screen = ReconstructViewSpacePositionFromDepth(inverse_proj, hit_pixel, depth).z;
        step_delta = marching_position.z - depth_from_screen;

        intersect = step_delta > 0.0;
        num_iterations += 1.0;

        if (intersect) {
            break;
        }
    }

    if (intersect) {
        // binary search
        for (; i < ssr_params.num_iterations; i++) {
            ray_step *= 0.5;
            marching_position = marching_position - ray_step * sign(step_delta);

            hit_pixel = GetProjectedPositionFromView(scene.projection, marching_position);
            depth_from_screen = abs(ReconstructViewSpacePositionFromDepth(inverse_proj, hit_pixel, SampleDepth(hit_pixel)).z);
            step_delta = abs(marching_position.z) - depth_from_screen;

            if (abs(step_delta) < ssr_params.distance_bias) {
                // hit_weight = smoothstep(0.1, 0.95, max(abs(hit_pixel.x), abs(hit_pixel.y)));
                return true;
            }
        }
    }

    return false;
}

float CalculateAlpha(
    float num_iterations,
    vec2 hit_pixel,
    vec3 hit_point,
    float dist,
    vec3 ray_direction
)
{
    float alpha = 1.0;
    // Fade ray hits that approach the maximum iterations
    alpha *= 1.0 - (num_iterations / ssr_params.num_iterations);

    // Fade ray hits that approach the screen edge
    vec2 hit_pixel_ndc = hit_pixel * 2.0 - 1.0;
    float max_dimension = Saturate(max(abs(hit_pixel_ndc.x), abs(hit_pixel_ndc.y)));
    // alpha *= 1.0 - max(0.0, max_dimension - ssr_params.screen_edge_fade_start) / (1.0 - ssr_params.screen_edge_fade_end);

    alpha = 1.0 - smoothstep(0.1, 0.9, max_dimension);

    // const float dp = dot(ray_direction, -scene.camera_direction.xyz);
    // alpha *= 1.0 - smoothstep(0.8, 1.0, dp);

    // Fade ray hits base on how much they face the camera
    // float eye_direction = clamp(ray_direction.z, ssr_params.eye_fade_start, ssr_params.eye_fade_end);
    // alpha *= 1.0 - (eye_direction - ssr_params.eye_fade_start) / (ssr_params.eye_fade_end - ssr_params.eye_fade_start);

    // Fade ray hits based on distance from ray origin
    // alpha *= 1.0 - clamp(dist / ssr_params.max_ray_distance, 0.0, 1.0);

    return alpha;
}

void main(void)
{
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    if (any(greaterThanEqual(coord, ssr_params.dimension))) {
        return;
    }

    vec2 texcoord = (vec2(coord) + 0.5) / vec2(ssr_params.dimension);

    const mat4 inverse_proj = inverse(scene.projection);

    const float roughness = Texture2D(sampler_nearest, gbuffer_material_texture, texcoord).r;
    const float perceptual_roughness = sqrt(roughness);

    vec3 N = DecodeNormal(Texture2D(sampler_nearest, gbuffer_normals_texture, texcoord));
    const float depth = SampleDepth(texcoord);

    if (depth > 0.9995) {
        imageStore(ssr_uvs, coord,  vec4(0.0));
        return;
    }

    vec3 P = ReconstructViewSpacePositionFromDepth(inverse_proj, texcoord, depth).xyz;
    vec3 V = normalize(vec3(0.0) - P);
    vec3 view_space_normal = normalize((scene.view * vec4(N, 0.0)).xyz);

    vec3 ray_origin = P;
    
    // scatter the ray based on surface roughness
    uint ray_seed = InitRandomSeed(InitRandomSeed(uint(coord.x), uint(coord.y)), scene.frame_counter % 4);

    vec3 rnd = vec3(RandomFloat(ray_seed), RandomFloat(ray_seed), RandomFloat(ray_seed));
    vec3 scattered_direction = normalize(view_space_normal + RandomInHemisphereCosineWeighted(rnd, view_space_normal) * roughness);
    vec3 ray_direction = reflect(normalize(ray_origin), scattered_direction);

    vec2 hit_pixel;
    vec3 hit_point;
    float hit_weight;
    float num_iterations;

    bool intersect = TraceRays(ray_origin, ray_direction, hit_pixel, hit_point, hit_weight, num_iterations);

    float dist = distance(ray_origin, hit_point);

    float alpha = CalculateAlpha(num_iterations, hit_pixel, hit_point, dist, ray_direction) * float(intersect);
    alpha = mix(alpha, 0.0, saturate(roughness / MAX_ROUGHNESS));

    imageStore(ssr_uvs, coord, vec4(hit_pixel, 0.0, alpha));
}