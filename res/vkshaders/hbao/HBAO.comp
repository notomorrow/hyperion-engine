#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_nonuniform_qualifier : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "../include/defines.inc"
#include "../include/shared.inc"
#include "../include/noise.inc"
#include "../include/packing.inc"

#define HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS
#include "../include/scene.inc"
#undef HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

layout(set = 0, binding = 0) uniform texture2D gbuffer_albedo_texture;
layout(set = 0, binding = 1) uniform texture2D gbuffer_normals_texture;
layout(set = 0, binding = 2) uniform texture2D gbuffer_depth_texture;
layout(set = 0, binding = 3) uniform texture2D gbuffer_velocity_texture;
layout(set = 0, binding = 4) uniform sampler sampler_nearest;
layout(set = 0, binding = 5) uniform sampler sampler_linear;

layout(std140, set = 0, binding = 6, row_major) readonly buffer SceneBuffer
{
    Scene scene;
};

layout(set = 0, binding = 7, rgba8) uniform image2D output_image;
layout(set = 0, binding = 8) uniform texture2D prev_image;

layout(push_constant) uniform PushConstant
{
    uvec2 dimension;
    float temporal_blending_factor;
};

#include "../include/Temporal.glsl"


#define HBAO_OLD 0

#define HYP_HBAO_NUM_CIRCLES 4
#define HYP_HBAO_NUM_SLICES 2
#define HYP_HBAO_RADIUS 32.0
#define HYP_HBAO_POWER 1.5
#define HYP_HBIL_POWER 1.0
#define HYP_HBAO_THICKNESS 1.0

float fov_rad = HYP_FMATH_DEG2RAD(scene.camera_fov);
float tan_half_fov = tan(fov_rad * 0.5);
float inv_tan_half_fov = 1.0 / tan_half_fov;
vec2 focal_len = vec2(inv_tan_half_fov * (float(scene.resolution_y) / float(scene.resolution_x)), inv_tan_half_fov);
vec2 inv_focal_len = vec2(1.0) / focal_len;
vec4 uv_to_view = vec4(2.0 * inv_focal_len.x, 2.0 * inv_focal_len.y, -1.0 * inv_focal_len.x, -1.0 * inv_focal_len.y);

float GetOffsets(vec2 uv)
{
    ivec2 position = ivec2(uv * vec2(dimension));
    return 0.25 * float((position.y - position.x) & 3);
}

mat4 inv_view_proj = inverse(scene.projection * scene.view);
mat4 inv_proj = inverse(scene.projection);

float GetDepth(vec2 uv)
{
    return Texture2DLod(sampler_nearest, gbuffer_depth_texture, uv, 0.0).r;
}

vec3 GetPosition(vec2 uv, float depth)
{
    return ReconstructViewSpacePositionFromDepth(inv_proj, uv, depth).xyz;
    // const float linear_depth = ViewDepth(depth, scene.camera_near, scene.camera_far);
    // return vec3((vec2(uv.x, 1.0 - uv.y) * uv_to_view.xy + uv_to_view.zw) * linear_depth, linear_depth);
}

vec3 GetNormal(vec2 uv)
{
    vec3 normal = DecodeNormal(Texture2DLod(sampler_nearest, gbuffer_normals_texture, uv, 0.0));
    vec3 view_normal = (scene.view * vec4(normal, 0.0)).xyz;

    return view_normal;
}

float IntegrateUniformWeight(vec2 h)
{
    vec2 arc = vec2(1.0) - cos(h);

    return arc.x + arc.y;
}

float IntegrateArcCosWeight(vec2 h, float n)
{
    vec2 arc = -cos(2.0 * h - n) + cos(n) + 2.0 * h * sin(n);

    return 0.25 * (arc.x + arc.y);
}

vec2 RotateDirection(vec2 uv, vec2 cos_sin)
{
    return vec2(
        uv.x * cos_sin.x - uv.y * cos_sin.y,
        uv.x * cos_sin.y + uv.y * cos_sin.x
    );
}

float IntegrateSolidAngle(vec2 integral_factors, float cos_theta0, float cos_theta1)
{
    float theta0, theta1;

    theta0 = acos(cos_theta0);
    theta1 = acos(cos_theta1);

    float sin_theta0, sin_theta1;

    sin_theta0 = sqrt(1.0 - HYP_FMATH_SQR(cos_theta0));
    sin_theta1 = sqrt(1.0 - HYP_FMATH_SQR(cos_theta1));

    const float integral_x = (theta1 - sin_theta1 * cos_theta1) - (theta0 - sin_theta0 * cos_theta0);
    const float integral_y = cos_theta0 * cos_theta0 - cos_theta1 * cos_theta1;

    return integral_factors.x * integral_x + integral_factors.y * integral_y;
}


void TraceAO_Old(vec2 uv, out float occlusion, out vec3 bent_normal, out vec4 light_color)
{
    uvec2 pixel_coord = clamp(uvec2(uv * vec2(dimension) - 0.5), uvec2(0), dimension - 1);
    uint seed = InitRandomSeed(InitRandomSeed(pixel_coord.x, pixel_coord.y), scene.frame_counter);

    const float projected_scale = float(dimension.y) / (tan_half_fov * 2.0) * 0.5;

    const float temporal_offset = GetSpatialOffset(scene.frame_counter);
    const float temporal_rotation = GetTemporalRotation(scene.frame_counter);

    const float noise_offset = GetOffsets(uv);
    const float noise_direction = InterleavedGradientNoise(vec2(pixel_coord));
    const float ray_step = fract(noise_offset + temporal_offset);

    const float depth = GetDepth(uv);
    const vec3 P = GetPosition(uv, depth);
    const vec3 N = GetNormal(uv);
#if HBAO_OLD
    const vec3 V = normalize(vec3(0.0) - P);
#else
    const vec3 V = normalize(P);
#endif



    const float camera_distance = P.z;
    const vec2 texel_size = vec2(1.0) / vec2(dimension);
#if HBAO_OLD
    const float step_radius = max((projected_scale * HYP_HBAO_RADIUS) / max(camera_distance, HYP_FMATH_EPSILON), float(HYP_HBAO_NUM_SLICES)) / float(HYP_HBAO_NUM_SLICES + 1);
#else
    const float step_radius = max((projected_scale * 2.0 * HYP_HBAO_RADIUS) / max(camera_distance, HYP_FMATH_EPSILON), float(HYP_HBAO_NUM_SLICES)) / float(HYP_HBAO_NUM_SLICES + 1);
#endif

    occlusion = 0.0;
    bent_normal = vec3(0.0);
    light_color = vec4(0.0);

    for (int i = 0; i < HYP_HBAO_NUM_CIRCLES; i++) {

        float angle = (float(i) + noise_direction + ((temporal_rotation / 360.0))) * (HYP_FMATH_PI / float(HYP_HBAO_NUM_CIRCLES)) * 2.0;
#if !HBAO_OLD
        // const vec3 slice_dir = vec3(cos(angle), sin(angle), 0.0);
        // const vec3 ray = normalize(vec3((slice_dir.xy * - 1.0) * V.z, dot(V.xy, slice_dir.xy)));

        
        vec3 slice_dir = { cos(angle), sin(angle), 0.0 };
        // const vec3 ray = normalize(vec3(slice_dir.xy * -V.z, -dot(-V.xy, slice_dir.xy)));
        // slice_dir.y *= -1.0;



        vec2 horizons = vec2(-1.0);

        const vec3 plane_normal = normalize(cross(slice_dir, V));
        const vec3 plane_tangent = cross(V, plane_normal);
        const vec3 projected_normal = N - plane_normal * dot(N, plane_normal);
        const float projected_length = length(projected_normal);

        const float cos_n = clamp(dot(normalize(projected_normal), V), -1.0, 1.0);
        const float n = -sign(dot(projected_normal, plane_tangent)) * acos(cos_n);
        
        // const vec2 camera_normals = { dot(ray, N), dot(N, -V) };
        // const vec2 integral_factors = 0.5 * vec2(dot(N.xy, camera_normals.xy), N.z);

        vec4 local_light[2] = { vec4(0.0), vec4(0.0) };
#else
        vec2 ss_ray = { sin(angle), cos(angle) };
        const vec3 ray = normalize(vec3(ss_ray * V.z, -dot(V.xy, ss_ray)));
        ss_ray.y *= -1.0;

        const vec2 n = { dot(ray, N), -dot(N, V) };
        
        float cos_max_theta = -n.x * inversesqrt(HYP_FMATH_SQR(n.x) + max(n.y, 0.0) * n.y);
        float max_theta = acos(cos_max_theta);

        float local_occlusion = 0.0;
#endif

        for (int j = 0; j < HYP_HBAO_NUM_SLICES; j++) {

#if !HBAO_OLD
            // R1 sequence (http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/)
            const float step_base_noise = float(i + j * HYP_HBAO_NUM_SLICES) * 0.6180339887498948482;
            const float step_noise = fract(noise_direction + step_base_noise);
        
            const vec2 uv_offset = (slice_dir.xy * texel_size) * max(step_radius * (float(j) + ray_step), float(j + 1));
            const vec4 uv_slice = uv.xyxy + vec4(uv_offset, -uv_offset);

            if (uvec4(uv_slice * vec4(dimension.xyxy) - vec4(0.5)) == pixel_coord.xyxy || abs(uv_slice) != Saturate(abs(uv_slice))) {
                continue;
            }

            const vec2 depths = { GetDepth(uv_slice.xy), GetDepth(uv_slice.zw) };

            const vec3 ds = GetPosition(uv_slice.xy, depths.x) - P;
            const vec3 dt = GetPosition(uv_slice.zw, depths.y) - P;
            

            const vec2 dsdt = vec2(dot(ds, ds), dot(dt, dt));
            const vec2 dsdt_length = inversesqrt(dsdt);

            const vec2 falloff = Saturate(dsdt * (2.0 / HYP_FMATH_SQR(HYP_HBAO_RADIUS)));

            const vec2 delta_v = vec2(dot(ds, V), dot(dt, V));
            const vec2 H = delta_v * dsdt_length;

            // vec4 delta_ss = vec4(delta_v.x, dot(ds, ray), delta_v.y, dot(dt, ray));
            const vec2 dist = vec2(length(ds), length(dt)) / HYP_HBAO_RADIUS;//vec2(length(delta_ss.xy), length(delta_ss.zw)) / HYP_HBAO_RADIUS;

            // vec2 tmp_horizons = acos(clamp(H, vec2(-1.0), vec2(1.0)));
            // tmp_horizons.x = n + max(-H.x - n, -HYP_FMATH_PI_HALF);
            // tmp_horizons.y = n + min(H.y - n, HYP_FMATH_PI_HALF);
            // const float tmp_weight = IntegrateUniformWeight(tmp_horizons);

            const vec2 weight = vec2(dot(ds, N), dot(dt, N));

            local_light[0] = mix(
                local_light[0],
                mix(vec4(Texture2DLod(sampler_linear, gbuffer_albedo_texture, uv_slice.xy, 0.0).rgb, 1.0) * (weight.xxxx - local_light[0]), local_light[0], 0.0),//falloff.x),
                float(H.x > horizons.x)
            );
            local_light[1] = mix(
                local_light[1],
                mix(vec4(Texture2DLod(sampler_linear, gbuffer_albedo_texture, uv_slice.zw, 0.0).rgb, 1.0) * (weight.yyyy - local_light[1]), local_light[1], 0.0),//falloff.y),
                float(H.y > horizons.y)
            );

            // if (H.x > horizons.x) {
            //     local_light[0] = vec4(Texture2DLod(sampler_linear, gbuffer_albedo_texture, uv_slice.xy, 0.0).rgb * IntegrateArcCosWeight(H, n), 1.0);
            // }

            // if (H.y > horizons.y) {
            //     local_light[1] = vec4(Texture2DLod(sampler_linear, gbuffer_albedo_texture, uv_slice.zw, 0.0).rgb * IntegrateArcCosWeight(H, n), 1.0);
            // }

            // const vec2 weights = { IntegrateSolidAngle(integral_factors, H.x, horizons.x), IntegrateSolidAngle(integral_factors * vec2(-1.0, 1.0), H.y, horizons.y) };

            // local_light[0] += vec4(Texture2DLod(sampler_linear, gbuffer_albedo_texture, uv_slice.xy, 0.0).rgb, 1.0) * float(H.x > horizons.x) * float(dist.x < 1.0 && dist.x > 0.05);// * tmp_weight;
            // local_light[1] += vec4(Texture2DLod(sampler_linear, gbuffer_albedo_texture, uv_slice.zw, 0.0).rgb, 1.0) * float(H.y > horizons.y) * float(dist.y < 1.0 && dist.y > 0.05);// * tmp_weight;
            
            // horizons = max(horizons, mix(H, horizons, falloff));
            horizons = mix(
                mix(H, horizons, HYP_HBAO_THICKNESS),
                mix(H, horizons, falloff),
                greaterThan(H, horizons)
            );
#else

            vec2 uv_offset = (ss_ray * texel_size) * max(step_radius * (float(j) + ray_step), float(j + 1));
            uv_offset *= mix(-1.0, 1.0, float(j % 2 == 0));

            const vec2 new_uv = uv_offset + uv;

            if (uvec2(new_uv * vec2(dimension - 1)) != pixel_coord && new_uv == Saturate(new_uv)) {
                const float new_depth = GetDepth(new_uv);
                const vec3 new_pos = GetPosition(new_uv, new_depth);
                const vec3 new_color = Texture2DLod(sampler_linear, gbuffer_albedo_texture, new_uv, 0.0).rgb;
                const vec3 new_normal = GetNormal(new_uv);

                vec3 delta = new_pos - P;
                vec2 delta_ss = { -dot(delta, V), dot(delta, ray) };
                const float len = length(delta);
                const float len_ss = length(delta_ss);
                delta /= len;

                const float dist = len_ss / HYP_HBAO_RADIUS;
                const float cos_theta = delta_ss.x / len_ss;

                if ((cos_theta >= cos_max_theta) && dist <= 0.99) {
                    const float theta = acos(cos_theta);

                    float falloff = (1.0 / max(len, HYP_FMATH_EPSILON));
                    falloff *= falloff;
                    falloff = Saturate(falloff);

                    const float weight = smoothstep(0.05, 0.4, dist);

                    light_color += vec4(new_color, 1.0) * weight;//(weight.xxxx - light_color);

                    max_theta += (theta - max_theta) * falloff;
                    cos_max_theta = cos(max_theta);

                    local_occlusion += (1.0 - HYP_FMATH_SQR(dist)) * (dot(delta, N) - local_occlusion);
                }
            }
#endif
        }

#if !HBAO_OLD
        horizons = acos(clamp(horizons, vec2(-1.0), vec2(1.0)));
        horizons.x = n + max(-horizons.x - n, -HYP_FMATH_PI_HALF);
        horizons.y = n + min(horizons.y - n, HYP_FMATH_PI_HALF);

        const float bent_angle = (horizons.x + horizons.y) * 0.5;
        const float arc_cos_weight = IntegrateArcCosWeight(horizons, n);

        bent_normal += V * cos(bent_angle) - plane_tangent * sin(bent_angle);
        occlusion += 1.0 - (projected_length * arc_cos_weight);

        light_color += local_light[0];// * arc_cos_weight;
        light_color += local_light[1];// * arc_cos_weight;
#else
        occlusion += local_occlusion;
#endif
    }

    // bent_normal = normalize(normalize(bent_normal) - (V * 0.5));
    occlusion = 1.0 - Saturate(pow(occlusion / float(HYP_HBAO_NUM_CIRCLES), 1.0 / HYP_HBAO_POWER));
    light_color /= max(light_color.a, 1.0);
    // light_color /= float(HYP_HBAO_NUM_CIRCLES);
}


#define ANGLE_BIAS 0.2


void TraceAO_New(vec2 uv, out float occlusion, out vec3 bent_normal, out vec4 light_color)
{
    uvec2 pixel_coord = clamp(uvec2(uv * vec2(dimension) - 0.5), uvec2(0), dimension - 1);
    uint seed = InitRandomSeed(InitRandomSeed(pixel_coord.x, pixel_coord.y), scene.frame_counter);

    const float projected_scale = float(dimension.y) / (tan_half_fov * 2.0);

    const float temporal_offset = GetSpatialOffset(scene.frame_counter);
    const float temporal_rotation = GetTemporalRotation(scene.frame_counter);

    const float noise_offset = GetOffsets(uv);
    const float noise_direction = InterleavedGradientNoise(vec2(pixel_coord));
    const float ray_step = fract(noise_offset + temporal_offset);

    const float depth = GetDepth(uv);
    const vec3 P = GetPosition(uv, depth);
    const vec3 N = GetNormal(uv);
    const vec3 V = normalize(P);

    const float camera_distance = P.z;
    const vec2 texel_size = vec2(1.0) / vec2(dimension);
    const float step_radius = max((projected_scale * HYP_HBAO_RADIUS) / max(camera_distance, HYP_FMATH_EPSILON), float(HYP_HBAO_NUM_SLICES)) / float(HYP_HBAO_NUM_SLICES + 1);

    occlusion = 0.0;
    bent_normal = vec3(0.0);
    light_color = vec4(0.0);

    for (int i = 0; i < HYP_HBAO_NUM_CIRCLES; i++) {

        float angle = (float(i) + noise_direction + ((temporal_rotation / 360.0))) * (HYP_FMATH_PI / float(HYP_HBAO_NUM_CIRCLES)) * 2.0;

        vec2 ss_ray = { sin(angle), cos(angle) };
        const vec3 camera_space_ray = normalize(vec3(ss_ray * V.z, -dot(V.xy, ss_ray)));
        ss_ray.y *= -1.0;

        const vec2 n = { dot(camera_space_ray, N), -dot(N, V) };


        // vec2 horizons = vec2(-1.0);
        vec2 horizons = vec2(-n.x * inversesqrt(HYP_FMATH_SQR(n.x) + max(n.y, 0.0) * n.y));

        // const float tangent_angle = acos(dot(vec3(ss_ray, 0.0), N)) - HYP_FMATH_PI_HALF + ANGLE_BIAS;
        // vec2 horizons = vec2(tangent_angle);
        
        // float cos_max_theta = -n.x * inversesqrt(HYP_FMATH_SQR(n.x) + max(n.y, 0.0) * n.y);
        // float max_theta = acos(cos_max_theta);

        // float local_occlusion = 0.0;

        vec2 slice_ao = vec2(0.0);
        vec4 slice_light = vec4(0.0);

        for (int j = 0; j < HYP_HBAO_NUM_SLICES; j++) {
            vec2 uv_offset = (ss_ray * texel_size) * max(step_radius * (float(j) + ray_step), float(j + 1));
            // uv_offset *= mix(-1.0, 1.0, float(j % 2 == 0));

            const vec4 new_uv = uv.xyxy + vec4(uv_offset, -uv_offset);

            // Fade hits that approach the screen edge
            const vec4 new_uv_ndc = new_uv * 2.0 - 1.0;
            const float max_dimension = min(1.0, max(abs(new_uv_ndc.x), abs(new_uv_ndc.y)));
            const float fade = 1.0;//1.0 - max(0.0, max_dimension - 0.55) / (1.0 - 0.85);

            if (new_uv.xy == Saturate(new_uv.xy)) {
                vec3 ds = GetPosition(new_uv.xy, GetDepth(new_uv.xy)) - P;
                vec3 dt = GetPosition(new_uv.zw, GetDepth(new_uv.zw)) - P;

                const vec2 len = vec2(length(ds), length(dt));
                const vec2 dist = len / HYP_HBAO_RADIUS; //dsdt_length.x / HYP_HBAO_RADIUS;
                ds /= len.x; dt /= len.y;

                const vec2 DdotD = vec2(dot(ds, ds), dot(dt, dt));
                const vec2 NdotD = vec2(dot(ds, N), dot(dt, N));
                const vec2 VdotD = vec2(dot(ds, V), dot(dt, V));
                const vec2 RdotD = vec2(dot(ds, camera_space_ray), dot(dt, camera_space_ray));

                const vec4 dv = { -VdotD.x, RdotD.x, -VdotD.y, RdotD.y };
                const vec2 dv_length = { length(dv.xy), length(dv.zw) };

                // const vec2 H = vec2(dv.x, dv.z) * dsdt_length;
                // const vec2 H = vec2(atan(ds.z / length(ds.xy)), atan(dt.z / length(dt.xy)));// * dsdt_length;

                // vec2 H = vec2(HYP_FMATH_PI_HALF) - acos(vec2(dot(N, ds), dot(N, dt)));

                // const float dist = len_ss / HYP_HBAO_RADIUS;
    
                const vec2 cos_theta = vec2(dv.x, dv.z) / dv_length;

                // const vec2 falloff = HYP_FMATH_SQR(dist / max(dsdt_length, vec2(HYP_FMATH_EPSILON)));
                const vec2 falloff = Saturate(DdotD * (2.0 / HYP_FMATH_SQR(HYP_HBAO_RADIUS)));

                const vec2 color_weights = smoothstep(0.05, 0.4, dist) * fade;
                const vec2 condition = vec2(greaterThan(cos_theta - falloff, horizons)) * vec2(lessThan(dist, vec2(0.995)));

                const vec3 new_color_0 = Texture2DLod(sampler_linear, gbuffer_albedo_texture, new_uv.xy, 0.0).rgb;
                const vec3 new_color_1 = Texture2DLod(sampler_linear, gbuffer_albedo_texture, new_uv.zw, 0.0).rgb;

                light_color = mix(
                    light_color,
                    light_color + vec4(new_color_0, 1.0),
                    condition.x * color_weights.x
                );

                light_color = mix(
                    light_color,
                    light_color + vec4(new_color_1, 1.0),
                    condition.y * color_weights.y
                );

                slice_ao = mix(
                    slice_ao,
                    slice_ao + vec2(
                        (1.0 - HYP_FMATH_SQR(dist.x)) * (NdotD.x - slice_ao.x),
                        (1.0 - HYP_FMATH_SQR(dist.y)) * (NdotD.y - slice_ao.y)
                    ),
                    condition
                );

                horizons = mix(horizons, cos_theta - falloff, condition);
            }
        }

        light_color += slice_light;
        occlusion += slice_ao.x + slice_ao.y;
    }

    // bent_normal = normalize(normalize(bent_normal) - (V * 0.5));
    occlusion = 1.0 - Saturate(pow(occlusion / float(HYP_HBAO_NUM_CIRCLES), 1.0 / HYP_HBAO_POWER));
    light_color /= max(light_color.a, 1.0);
    light_color.rgb = pow(light_color.rgb, vec3(1.0 / HYP_HBIL_POWER));

    // occlusion *= 1.0 / (1.0 - ANGLE_BIAS);
    // light_color *= 1.0 / (1.0 - ANGLE_BIAS);
    
    // light_color /= float(HYP_HBAO_NUM_CIRCLES * HYP_HBAO_NUM_SLICES * 2.0);
}

void main()
{
    const uvec2 pixel_coord = gl_GlobalInvocationID.xy;
    
    if (any(greaterThanEqual(pixel_coord, dimension))) {
        return;
    }

    const vec2 uv = (vec2(pixel_coord) + 0.5) / vec2(dimension);

    float occlusion;
    vec3 bent_normal;
    vec4 light_color;

#if HBAO_OLD
    TraceAO_Old(uv, occlusion, bent_normal, light_color);
#else
    TraceAO_New(uv, occlusion, bent_normal, light_color);
#endif

    // vec4 next_values = vec4(light_color.rgb, occlusion);
    vec4 next_values = vec4(light_color.rgb, occlusion);
    // vec4 next_values = vec4(light_color_2.rgb - light_color.rgb, occlusion_2 - occlusion);
    
    imageStore(output_image, clamp(ivec2(pixel_coord), ivec2(0.0), ivec2(dimension - 1)), next_values);
}