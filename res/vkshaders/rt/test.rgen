#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

#define HYP_NO_CUBEMAP

#include "../include/defines.inc"
#include "../include/noise.inc"
#include "../include/packing.inc"

layout(set = 0, binding = 0) uniform accelerationStructureEXT tlas;
// radiance image
layout(set = 0, binding = 1, rgba8) uniform image2D image;
// normals packed (first 2 components), b is roughness, a will be weight
layout(set = 0, binding = 2, rgba8) uniform image2D normals_roughness_weight_image;
layout(set = 0, binding = 3, r32f) uniform image2D depth_image;

#define HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

#include "../include/scene.inc"
#include "../include/shared.inc"
#include "../include/noise.inc"

#undef HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS
#undef HYP_NO_CUBEMAP

layout(std140, set = 1, binding = 0, row_major) readonly buffer SceneShaderData
{
    Scene scene;
};

#include "../include/rt/payload.inc"

layout(location = 0) rayPayloadEXT RayPayload payload;
#define MAX_RECURSION 2
#define RAY_OFFSET 1.0
#define NUM_SAMPLES 1

void main() 
{
    const mat4 view_inverse = inverse(scene.view);
    const mat4 projection_inverse = inverse(scene.projection);

    const uint flags = gl_RayFlagsOpaqueEXT;
    const uint mask = 0xff;
    const float tmin = 0.001;
    const float tmax = 10000.0;

    uint ray_seed = InitRandomSeed(InitRandomSeed(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), scene.frame_counter);

#define HIT_CACHE_SIZE MAX_RECURSION
#define FIRST_HIT hits[0]

    RayHit hits[HIT_CACHE_SIZE];

    vec3 color = vec3(0.0);

    uint pixel_seed = 0xabcdef;

    for (int sample_index = 0; sample_index < NUM_SAMPLES; sample_index++) {
        const vec2 pixel_center = vec2(gl_LaunchIDEXT.x + RandomFloat(pixel_seed), gl_LaunchIDEXT.y + RandomFloat(pixel_seed));
        const vec2 uv = pixel_center / vec2(gl_LaunchSizeEXT.xy);
        const vec2 d = uv * 2.0 - 1.0;
        
        vec4 target = projection_inverse * vec4(d.x, d.y, 1, 1) ;
        vec4 direction = view_inverse * vec4(normalize(target.xyz / target.w), 0);
        vec4 origin = view_inverse * vec4(0, 0, 0, 1);

        for (int ray_index = 0; ray_index < MAX_RECURSION; ray_index++) {
            traceRayEXT(tlas, flags, mask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);

            vec4 pos = origin + direction * payload.distance;
            pos /= pos.w;

            RayHit hit;
            hit.payload = payload;
            hit.position = pos.xyz;
            hits[ray_index] = hit;

            if (payload.distance < 0.0) {
                // color += hit.payload.color;
                break;
            } else if (ray_index < MAX_RECURSION - 1) {
                const vec4 hit_position = origin + direction * payload.distance;
                origin.xyz = hit_position.xyz + payload.normal * RAY_OFFSET;

                vec3 rnd = vec3(RandomFloat(ray_seed), RandomFloat(ray_seed), RandomFloat(ray_seed));
                vec3 scattered_direction = RandomInHemisphere(rnd, payload.normal);

                vec3 ray_dir = normalize(payload.normal + scattered_direction * payload.roughness);

                direction.xyz = normalize(reflect(direction.xyz, ray_dir));
            } else {
                color += hit.payload.color;
                break;
            }
        }
    }

    color /= float(NUM_SAMPLES);

    const ivec2 resolution = imageSize(image);
    const ivec2 storage_coord = clamp(ivec2(gl_LaunchIDEXT.xy), ivec2(0), resolution - ivec2(1));

    imageStore(image, storage_coord, vec4(color, 1.0));

    const vec4 first_hit_ndc_position = scene.projection * scene.view * vec4(FIRST_HIT.position, 1.0);
    const float first_hit_depth = FIRST_HIT.payload.distance >= 0.0
        ? first_hit_ndc_position.z / first_hit_ndc_position.w
        : 1.0;
    imageStore(depth_image, storage_coord, vec4(first_hit_depth));

    // calculate blur radius
    const float cone_angle = RoughnessToConeAngle(FIRST_HIT.payload.roughness);
    const float cone_length = payload.distance;
    const float radius = cone_length * tan(cone_angle);

    vec4 normals_roughness_weight = vec4(0.0);
    normals_roughness_weight.xy = PackNormalVec2(payload.normal.xyz);
    normals_roughness_weight.z = payload.roughness;
    normals_roughness_weight.a = radius / 255.0;//FIRST_HIT.payload.roughness;//radius;

    imageStore(normals_roughness_weight_image, storage_coord, normals_roughness_weight);
}
