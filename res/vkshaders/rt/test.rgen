#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

#define HYP_NO_CUBEMAP

#include "../include/defines.inc"
#include "../include/noise.inc"
#include "../include/packing.inc"

layout(set = 0, binding = 0) uniform accelerationStructureEXT tlas;
// radiance image
layout(set = 0, binding = 1, rgba8) uniform image2D image;

#define HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

#include "../include/scene.inc"
#include "../include/shared.inc"
#include "../include/noise.inc"
#include "../include/brdf.inc"

#undef HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS
#undef HYP_NO_CUBEMAP

layout(std140, set = 1, binding = 0, row_major) readonly buffer SceneShaderData
{
    Scene scene;
};

#include "../include/rt/payload.inc"

const float spatial_offsets[] = { 0.0, 0.5, 0.25, 0.75 };
const float temporal_rotations[] = { 60, 300, 180, 240, 120, 0 };

layout(location = 0) rayPayloadEXT RayPayload payload;
#define MAX_RECURSION 2
#define RAY_OFFSET 1.0
#define NUM_SAMPLES 1
#define NUM_ACCUMULATION_SAMPLES 6

void ComputeOrthonormalBasis(in vec3 normal, out vec3 bitangent, out vec3 tangent)
{
    vec3 T;
    T = cross(normal, vec3(0.0, 1.0, 0.0));
    T = mix(cross(normal, vec3(1.0, 0.0, 0.0)), T, step(HYP_FMATH_EPSILON, dot(T, T)));

    T = normalize(T);

    tangent = T;
    bitangent = normalize(cross(normal, T));
}

const vec2 offsets[5] = vec2[](
    vec2(-1, -1),
    vec2(0, -1),
    vec2(0, 0),
    vec2(1, 0),
    vec2(1, 1)
);

mat3 getNormalSpace(in vec3 normal) {
   vec3 someVec = vec3(1.0, 0.0, 0.0);
   float dd = dot(someVec, normal);
   vec3 tangent = vec3(0.0, 1.0, 0.0);
   if(1.0 - abs(dd) > 1e-6) {
     tangent = normalize(cross(someVec, normal));
   }
   vec3 bitangent = cross(normal, tangent);
   return mat3(tangent, bitangent, normal);
}

void main() 
{
    const mat4 view_inverse = inverse(scene.view);
    const mat4 projection_inverse = inverse(scene.projection);

    const uint flags = gl_RayFlagsOpaqueEXT;
    const uint mask = 0xff;
    const float tmin = 0.001;
    const float tmax = 10000.0;

    uint ray_seed = InitRandomSeed(InitRandomSeed(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), scene.frame_counter);

#define HIT_CACHE_SIZE MAX_RECURSION
#define FIRST_HIT hits[0]

    RayHit hits[HIT_CACHE_SIZE];

    vec3 color = vec3(0.0);

    // const float temporal_offset = GetSpatialOffset(scene.frame_counter);
    const float noise_direction = RandomFloat(ray_seed);//InterleavedGradientNoise(vec2(pixel_coord));
    const float temporal_rotation = temporal_rotations[scene.frame_counter % 6] / 360.0;

    // TODO: Only need one ray, we can just use screen space depth/normals
    
    uint pixel_seed = 0xabcdef;
    const vec2 pixel_offset = vec2(RandomFloat(ray_seed), RandomFloat(ray_seed));//Hammersley(scene.frame_counter % NUM_ACCUMULATION_SAMPLES, NUM_ACCUMULATION_SAMPLES);

    for (int sample_index = 0; sample_index < NUM_SAMPLES; sample_index++) {
        const vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + pixel_offset;
        const vec2 uv = pixel_center / vec2(gl_LaunchSizeEXT.xy);
        const vec2 d = uv * 2.0 - 1.0;
        
        vec4 target = projection_inverse * vec4(d.x, d.y, 1.0, 1.0);
        vec4 direction = view_inverse * vec4(normalize(target.xyz / target.w), 0);
        vec4 origin = view_inverse * vec4(0, 0, 0, 1);

        for (int ray_index = 0; ray_index < MAX_RECURSION; ray_index++) {
            traceRayEXT(tlas, flags, mask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);

            vec4 pos = origin + direction * payload.distance;
            pos /= pos.w;

            RayHit hit;
            hit.payload = payload;
            hit.position = pos.xyz;
            hits[ray_index] = hit;

            if (payload.distance < 0.0) {
                // color += hit.payload.color;
                break;
            } else if (ray_index < MAX_RECURSION - 1) {
                vec4 hit_position = origin + direction * payload.distance;
                
                origin.xyz = hit_position.xyz + payload.normal * RAY_OFFSET;

                const float angle = (noise_direction + temporal_rotation) * HYP_FMATH_PI * 2.0;

                const float cone_angle = RoughnessToConeAngle(payload.roughness);
                const float cone_length = payload.distance;
                const float radius = cone_length * tan(cone_angle);

                // const vec3 rnd = random_pcg3d(uvec3(scene.frame_counter % 6, gl_LaunchIDEXT.xy));
                vec3 rnd = vec3(RandomFloat(ray_seed), RandomFloat(ray_seed), RandomFloat(ray_seed));
                vec3 scattered_direction = RandomInHemisphere(rnd, payload.normal);
                
                
                    //vec3(RandomFloat(ray_seed), RandomFloat(ray_seed), RandomFloat(ray_seed));//Hammersley(scene.frame_counter % NUM_ACCUMULATION_SAMPLES, NUM_ACCUMULATION_SAMPLES) * 0.5 + 0.5;

                



                // vec3 scattered_direction = normalize(payload.normal + RandomInHemisphereCosineWeighted(rnd, payload.normal) * payload.roughness);
                // vec3 ray_direction = reflect(normalize(origin.xyz), scattered_direction);


                
                // const vec2 rnd = vec2(RandomFloat(ray_seed), RandomFloat(ray_seed));//Hammersley(scene.frame_counter % NUM_ACCUMULATION_SAMPLES, NUM_ACCUMULATION_SAMPLES) * 0.5 + 0.5;
                // vec3 scattered_direction = normalize(payload.normal + CosWeightedRandomHemisphereDirectionHammersley(scene.frame_counter % NUM_ACCUMULATION_SAMPLES, NUM_ACCUMULATION_SAMPLES, payload.normal) * 0.01); //Hammersley(scene.frame_counter % NUM_ACCUMULATION_SAMPLES, NUM_ACCUMULATION_SAMPLES);// //Hammersley(scene.frame_counter % NUM_ACCUMULATION_SAMPLES, NUM_ACCUMULATION_SAMPLES);////, RandomFloat(ray_seed));
                // vec3 scattered_direction = ImportanceSampleGGX(rnd, payload.normal, HYP_FMATH_SQR(payload.roughness));//RandomInHemisphere(rnd, payload.normal);

                // vec3 ray_dir = mix(payload.normal, scattered_direction, payload.roughness);
                scattered_direction = normalize(payload.normal + scattered_direction * payload.roughness);

                // float a = payload.roughness * payload.roughness;
                // float theta = acos(sqrt((1.0 - rnd.y) / (1.0 + (a * a - 1.0) * rnd.y)));
                // float phi = 2.0 * HYP_FMATH_PI * rnd.x;
                
                // vec3 localH = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
                // vec3 H = getNormalSpace(payload.normal) * localH;  



                direction.xyz = normalize(reflect(direction.xyz, scattered_direction));

                // direction.xyz = ray_direction;
            } else {
                color += hit.payload.color;
                break;
            }
        }
    }

    color /= float(NUM_SAMPLES);

    const ivec2 resolution = imageSize(image);
    const ivec2 storage_coord = clamp(ivec2(gl_LaunchIDEXT.xy), ivec2(0), resolution - ivec2(1));

    imageStore(image, storage_coord, vec4(color, 1.0));

#if 0
    const vec4 first_hit_ndc_position = scene.projection * scene.view * vec4(FIRST_HIT.position, 1.0);
    const float first_hit_depth = FIRST_HIT.payload.distance >= 0.0
        ? first_hit_ndc_position.z / first_hit_ndc_position.w
        : 1.0;
    imageStore(depth_image, storage_coord, vec4(first_hit_depth));

    // calculate blur radius
    const float cone_angle = RoughnessToConeAngle(FIRST_HIT.payload.roughness);
    const float cone_length = payload.distance;
    const float radius = cone_length * tan(cone_angle);

    vec4 normals_roughness_weight = vec4(0.0);
    normals_roughness_weight.xy = PackNormalVec2(payload.normal.xyz);
    normals_roughness_weight.z = payload.roughness;
    normals_roughness_weight.a = radius / 255.0;//FIRST_HIT.payload.roughness;//radius;

    imageStore(normals_roughness_weight_image, storage_coord, normals_roughness_weight);
#endif
}
