
#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout  : require
#extension GL_EXT_nonuniform_qualifier : require

#define SIZE_X 8
#define SIZE_Y 8
#define SIZE_Z 8

layout(local_size_x = SIZE_X, local_size_y = SIZE_Y, local_size_z = SIZE_Z) in;

#define MAX_DISTANCE 300.0

#include "../include/defines.inc"
#include "../include/shared.inc"
#include "../include/tonemap.inc"

#define HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS
#include "../include/env_probe.inc"
#include "../include/scene.inc"

layout(set = 0, binding = 0) uniform texture3D sh_grid_images[9];
layout(set = 0, binding = 1) uniform sampler sampler_nearest;

layout(set = 0, binding = 2, rgba16f) uniform image3D sh_clipmaps[9];

layout(set = 0, binding = 3) uniform texture2D gbuffer_depth_texture;

layout(std140, set = 0, binding = 4, row_major) readonly buffer SceneBuffer {
    Scene scene;
};

layout(std140, set = 0, binding = 5, row_major) uniform CameraShaderData
{
    Camera camera;
};

layout(set = 0, binding = 6) uniform EnvGridBuffer {
    EnvGrid env_grid;
};

layout(std430, set = 0, binding = 7, row_major) readonly buffer EnvProbesBuffer {
    EnvProbe env_probes[];
};

layout(push_constant) uniform PushConstant {
    uvec4 clipmap_dimensions;
    vec4 cage_center_world;
};

int GetLocalEnvProbeIndex(vec3 world_position, out ivec3 unit_diff)
{
    const vec3 size_of_probe = env_grid.aabb_extent.xyz / vec3(env_grid.density.xyz);
    const ivec3 position_units = ivec3(world_position / size_of_probe + (vec3(env_grid.density.xyz) * 0.5));
    const ivec3 position_offset = position_units % ivec3(env_grid.density.xyz);//ivec3(fract((position_units / vec3(env_grid.density.xyz)) + 0.5) * vec3(env_grid.density.xyz));//position_units + vec3(env_grid.density.xyz) * 0.5;
    // const ivec3 position_in_grid = position_offset % //mod(position_offset, env_grid.density.xyz);

    unit_diff = position_offset;

    
    // const vec3 diff = world_position - env_grid.center.xyz;//(env_grid.aabb_extent.xyz * 0.5);
    // const vec3 pos_clamped = (diff / env_grid.aabb_extent.xyz) + 0.5;

    // if (any(greaterThanEqual(pos_clamped, vec3(1.0))) || any(lessThan(pos_clamped, vec3(0.0)))) {
    //     unit_diff = ivec3(0);
    //     return -1;
    // }

    // unit_diff = ivec3(pos_clamped * vec3(env_grid.density.xyz) /*- 0.5*/);

    int probe_index_at_point = (int(unit_diff.x) * int(env_grid.density.y) * int(env_grid.density.z))
        + (int(unit_diff.y) * int(env_grid.density.z))
        + int(unit_diff.z) + 1 /* + 1 because the first element is always the reflection probe */;

    return probe_index_at_point;
}

int GetProbeIndex(uvec3 coord_in_clipmap, out ivec3 coord_in_probe_grid)
{
    vec3 clipmap_uv = vec3(coord_in_clipmap) / vec3(clipmap_dimensions.xyz) - vec3(0.5);
    coord_in_probe_grid = ivec3((clipmap_uv + vec3(0.5)) * vec3(env_grid.density.xyz));

    int probe_index_at_point = (coord_in_probe_grid.x * int(env_grid.density.y) * int(env_grid.density.z))
        + (coord_in_probe_grid.y * int(env_grid.density.z))
        + coord_in_probe_grid.z + 1 /* + 1 because the first element is always the reflection probe */;

    return probe_index_at_point;
}

mat4 inverse_projection = inverse(camera.projection);

float GetViewSpaceDepth(vec2 uv, float depth)
{
    return ReconstructViewSpacePositionFromDepth(inverse_projection, uv, depth).z;
}

uvec3 CoordToClipmapCoord(vec2 uv, float depth)
{
    const float view_depth = GetViewSpaceDepth(uv, depth);
    const float view_depth_clamped = saturate(view_depth / MAX_DISTANCE);

    const vec3 pos = vec3(uv, view_depth_clamped);

    return min(uvec3(pos * vec3(clipmap_dimensions.xyz) - 0.5), clipmap_dimensions.xyz - 1);
}

void SetSH9InClipmap(uvec3 position, const in SH9 sh)
{
    // imageStore(sh_clipmaps[0], ivec3(position), vec4(sh.values[0].xyz, sh.values[1].x));
    // imageStore(sh_clipmaps[1], ivec3(position), vec4(sh.values[1].yz, sh.values[2].xy));
    // imageStore(sh_clipmaps[2], ivec3(position), vec4(sh.values[2].z, sh.values[3].xyz));
    // imageStore(sh_clipmaps[3], ivec3(position), vec4(sh.values[4].xyz, sh.values[5].x));
    // imageStore(sh_clipmaps[4], ivec3(position), vec4(sh.values[5].yz, sh.values[6].xy));
    // imageStore(sh_clipmaps[5], ivec3(position), vec4(sh.values[6].z, sh.values[7].xyz));
    // imageStore(sh_clipmaps[6], ivec3(position), vec4(sh.values[8].xyz, 0.0));

    imageStore(sh_clipmaps[0], ivec3(position), vec4(sh.values[0], 1.0));
    imageStore(sh_clipmaps[1], ivec3(position), vec4(sh.values[1], 1.0));
    imageStore(sh_clipmaps[2], ivec3(position), vec4(sh.values[2], 1.0));
    imageStore(sh_clipmaps[3], ivec3(position), vec4(sh.values[3], 1.0));
    imageStore(sh_clipmaps[4], ivec3(position), vec4(sh.values[4], 1.0));
    imageStore(sh_clipmaps[5], ivec3(position), vec4(sh.values[5], 1.0));
    imageStore(sh_clipmaps[6], ivec3(position), vec4(sh.values[6], 1.0));
    imageStore(sh_clipmaps[7], ivec3(position), vec4(sh.values[7], 1.0));
    imageStore(sh_clipmaps[8], ivec3(position), vec4(sh.values[8], 1.0));
}

#define PROBE_CAGE_VIEW_RANGE 50.0

void main(void)
{
    const uvec3 id = uvec3(gl_GlobalInvocationID.xyz);

    if (any(greaterThanEqual(id, clipmap_dimensions.xyz))) {
        return;
    }

    SH9 sh;

    vec3 uv = (vec3(id) + 0.5) / vec3(clipmap_dimensions.xyz);

    const vec3 scale = vec3(PROBE_CAGE_VIEW_RANGE) / vec3(clipmap_dimensions.xyz);
    const vec3 camera_position_snapped = (floor(camera.position.xyz / scale) + 0.5) * scale;

    const vec3 world_position = camera_position_snapped + ((((vec3(id) - vec3(clipmap_dimensions.xyz) * 0.5)) * scale));

    ivec3 probe_position;
    int probe_index_at_point = GetLocalEnvProbeIndex(world_position, probe_position);//GetProbeIndex(id, probe_position); 

    if (probe_index_at_point >= 1 && probe_index_at_point < HYP_MAX_BOUND_AMBIENT_PROBES) {
        const uint probe_index = GET_GRID_PROBE_INDEX(probe_index_at_point);

        if (probe_index != ~0u) {
            const ivec3 image_size = textureSize(sampler3D(sh_grid_images[0], sampler_nearest), 0);
            const vec3 texel_size = vec3(1.0) / vec3(image_size);

            EnvProbe probe = env_probes[probe_index];
            ivec3 storage_position = probe.position_in_grid.xyz;

            vec3 coord = (vec3(storage_position) + 0.5) * texel_size;

            for (int i = 0; i < 9; i++) {
                vec3 grid_color = Texture3D(sampler_nearest, sh_grid_images[i], coord).rgb;
                sh.values[i] = grid_color;//UINT_TO_VEC4(probe_index).rgb;
            }

            SetSH9InClipmap(id, sh);

            return;
        } else {
            for (int i = 0; i < 9; i++) {
                sh.values[i] = vec3(0.0, 0.0, 1.0);
            }

            SetSH9InClipmap(id, sh);

            return;
        }
    }

    if (probe_index_at_point < 0) {
        for (int i = 0; i < 9; i++) {
            sh.values[i] = vec3(0.0, 0.0, 0.0);
        }
    } else {
        for (int i = 0; i < 9; i++) {
            sh.values[i] = vec3(0.0, 0.0, 0.0);
        }
    }

    SetSH9InClipmap(id, sh);

}
