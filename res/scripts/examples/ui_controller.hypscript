#importpath "../" "../library";

import core::engine;
import core::{ AssertEqual, AssertNotEqual };
import scene::{ EntityProxy };

// dynamic import
//const tests = Module.Load("../tests");

enum UIEventType {
    NONE,

    MOUSE_DOWN,
    MOUSE_UP,
    MOUSE_DRAG,
    MOUSE_HOVER
}

let my_name : Name = new Name("Foo bar");
AssertEqual(my_name.hash_code, (new Name("Foo bar")).hash_code);
AssertNotEqual(my_name.hash_code, (new Name("Andrew")).hash_code);

Print("my_name = %", my_name);
my_name = new Name("Andrew");
AssertNotEqual(my_name.hash_code, (new Name("Foo bar")).hash_code);
AssertEqual(my_name.hash_code, (new Name("Andrew")).hash_code);
Print("my_name = %", my_name);
Print("my_name.LookupString() = %", my_name.LookupString());

class TestUIController {
    const receives_update : Bool = false;

    click_position : Vector2 = new Vector2();
    entity : EntityProxy = null;

    TestUIController(self : TestUIController)
    {
    }

    func OnAdded(self : TestUIController, entity : EntityProxy)
    {
        self.entity = entity;
    }

    func OnRemoved(self : TestUIController)
    {
        self.entity = null;
    }

    func OnTick(self : TestUIController, delta : Float)
    {
        Print("Tick UI Component")
    }

    func OnEvent(self : TestUIController, event_type : Int, mouse_position : Vector2)
    {
        const entity_position : Vector3 = self.entity.GetTranslation();
        const aabb : BoundingBox = self.entity.GetWorldAABB();
        const min = aabb.GetMin();
        const max = aabb.GetMax();

        const center : Vector3 = (max + min) * new Vector3(0.5, 0.5, 0.5);

        if (event_type == UIEventType.MOUSE_DOWN) {
            self.click_position = new Vector2(mouse_position.GetX() - entity_position.GetX(), mouse_position.GetY() - entity_position.GetY());

            let ent : EntityProxy = engine::CreateEntity();
            ent.SetTranslation(new Vector3(0, 20, 0));
            Print("ent.GetWorldAABB() = %\n", ent.GetWorldAABB());

        } else if (event_type == UIEventType.MOUSE_UP) {
            self.click_position = new Vector2(0.0, 0.0);
        } else if (event_type == UIEventType.MOUSE_DRAG) {
            self.entity.SetTranslation(new Vector3(mouse_position.GetX() + self.click_position.GetX(), mouse_position.GetY() + self.click_position.GetY()/*(mouse_position.GetY() - (1.0 - self.click_position.GetY()))*/, 0.0));
        }

        Print("world AABB = %\n", self.entity.GetWorldAABB());

        Print("self.entity = %\n", self.entity);
    }
};

class MyClass {
    j : Float = 4.5;
}

class TempClass : MyClass {
    i : Int = 4;
    static name : String = "TempClass";

    TempClass(self: TempClass)
    {
        Print("Create new TempClass!\n");
        Print("i = %\n", self.i);
    }

    // You can literally override the class type check...
    // static func operator==(const ref self : TempClass, other)
    // {
    //     // Temp
    //     return 12345;
    // }
}

// func MakeNewObjectWithTemplate<T>()
// {
//     Print("MakeNewObjectWithTemplate: %\n", T);

//     return new T;
// }

func MakeNewObject(cls : any)
{
    Print("MakeNewObject: %\n", cls);
    Print("does class % have $construct? %\n", cls.name, reflect::HasMember(cls, "$construct"));
    Print("does class % proto have $construct? %\n", cls.name, reflect::HasMember(cls.$proto, "$construct"));

    return new cls();
}

MakeNewObject(TempClass);
// MakeNewObjectWithTemplate<TempClass>();

let t : TempClass = new TempClass();

let x = new TempClass();

func GetIAndJ(obj : TempClass)
{
    Print("i = %\n", obj.i);
    Print("j = %\n", obj.j);
    // Print("obj.name = %\n", obj.name);

    Print("$proto of TempClass : %\n", TempClass.$proto);
    Print("base of TempClass : %\n", TempClass.base);

    Print("obj GetClass is %\n", reflect::GetClass(obj));
    Print("obj.GetClass memory address: %, TempClass memory address: %\n", GetMemoryAddress(reflect::GetClass(obj)), GetMemoryAddress(TempClass));
    Print(" is obj a TempClass ? : %\n", reflect::GetClass(obj) == TempClass);
    Print("Memory addresses equal? %\n", GetMemoryAddress(reflect::GetClass(obj)) == GetMemoryAddress(TempClass));
}

GetIAndJ(t);

Print("t.j = %\n", t.j);
Print("typeof(t.j) = %\n", typeof(t.j));


export const controller = new TestUIController;
