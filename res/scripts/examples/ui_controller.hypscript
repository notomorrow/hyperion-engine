#importpath "../" "../library";

import core::engine;
import core::{ AssertEqual, AssertNotEqual };
import scene::{ EntityProxy, Controller };
import containers::{ Struct };
import math;
import io::File;

// const File2 = io::File;
// dynamic import
//const tests = Module.Load("../tests");


func Expect( cond : Bool ) : Bool
{
    if (!cond) {
        throw "Assertion failed!";

        return false;
    }

    return true;
}

func Test(name : String, block : Function)
{
    Print("Test %\n", name);

    try {
        block(func (unit_name : String, unit_block : Function) {
            Print("Unit \"%\" ... ", unit_name);
            
            try {
                unit_block();

                Print("passed\n");
            } catch {
                Print("failed\n");
            }
        });
    } catch {
        Print("Test failed\n");
    }
}

Expect(math::NaN != math::NaN);
// Print("1 / 0 = %\n", 1 / 0);
// Print("NaN = %\n", math::NaN);

class MyClass {
    j : Float = 4.5;
}

class TempClass : MyClass {
    i : Int = 4;
    static name : String = "TempClass";

    TempClass(self: TempClass)
    {
        Print("Create new TempClass!\n");
        Print("i = %\n", self.i);
        Print("self.j = %\n", self.j);

        // return self;
    }

    // You can literally override the class type check...
    // static func operator==(const ref self : TempClass, other)
    // {
    //     // Temp
    //     return 12345;
    // }
}

func Foo() {
    let outer : Int = 179;

    class NestedClass {
        ref ref_member : Int = outer;
    }

    func MakeNewObjectWithTemplate<T = UInt, U = Float, Other...>()
    {
        Print("Hello Foo\n");
        let x : T;
        Print("typeof(x) = %\n", typeof(x));

        // Print("outer = %\n", outer);
        return U;
        // return 125;
    }

    func MakeNewObject(cls : Any)
    {
        Print("MakeNewObject: %\n", cls);
        Print("does class % have $construct? %\n", cls.name, HasMember(cls, "$construct"));
        Print("does class % proto have $construct? %\n", cls.name, HasMember(cls.$proto, "$construct"));

        return new cls();
    }

    MakeNewObject(TempClass);
    // MakeNewObjectWithTemplate<TempClass>();

    //Print("MakeNewObjectWithTemplate<Int, String, Float>() = %\n", MakeNewObjectWithTemplate<Int, "Hello World", Float>());

    let nested_object = new NestedClass;
    outer = 999;
    Print("nested_object.ref_member = %\n", nested_object.ref_member);

    return nested_object;
}

Print("typeof Foo = %\n", typeof(Foo));
Print("Foo() = %\n", Foo());
foo_result := Foo();
Print("foo_result = %\n", foo_result);

t : TempClass = new TempClass();
Print("GetClass(t) = %\n", GetClass(t));
// AssertEqual(GetClass(t), TempClass);

x := new TempClass();
Print("Bar\n");

func GetIAndJ(obj : TempClass)
{
    Print("Foo FOo\n");
    Print("obj = %\n", obj);
    Print("i = %\n", obj.i);
    Print("j = %\n", obj.j);
    // Print("obj.name = %\n", obj.name);

    Print("$proto of TempClass : %\n", TempClass.$proto);
    Print("base of TempClass : %\n", TempClass.base);

    Print("obj GetClass is %\n", GetClass(obj));
    Print("obj.GetClass memory address: %, TempClass memory address: %\n", GetMemoryAddress(GetClass(obj)), GetMemoryAddress(TempClass));
    Print(" is obj a TempClass ? : %\n", GetClass(obj) == TempClass);
    Print("Memory addresses equal? %\n", GetMemoryAddress(GetClass(obj)) == GetMemoryAddress(TempClass));
    Print("TempClass has $construct? %\n", TempClass has '$construct');
    Print("TempClass.$proto has $construct? %\n", TempClass.$proto has '$construct');
    Print("obj has $construct? %\n", obj has '$construct');

    Print("obj IsInstance of TempClass? %\n", IsInstance(obj, TempClass));
    Print("obj IsInstance of Int? %\n", IsInstance(obj, Int));
    Print("5 IsInstance of Int? %\n", IsInstance(5, Int));
    Print("0 IsInstance of Int? %\n", IsInstance(0, Int));
    Print("null IsInstance of Int? %\n", IsInstance(null, Int));
    Print("obj IsInstance of new TempClass? %\n", IsInstance(obj, new TempClass));
}

func GenericFunction2 <T> (t : T, cond : Bool) : T
{
    return cond ? t : t - 1;
}
AssertEqual(typeof(GenericFunction2<Int>(2, true)), "Int");
AssertEqual(typeof(GenericFunction2<Float>(2.0, true)), "Float");
//Print(typeof(GenericFunction2<9>));

GetIAndJ(t);

Print("File.class == %\n", io::File.class);
Print("File.base == %\n", io::File.base);
Print("File is class? %\n", IsInstance(io::File, Class));
Print("Int = %\n", Int);
Print("(new io::File).class = %\n", (new io::File("test.txt")).class);
Print("File.class = %\n", io::File.class);
Print("typeof(io::File) = %\n", typeof(io::File));
Expect(IsInstance(io::File, Class));
Expect(IsInstance(new io::File("test.txt"), io::File));

Expect(typeof([1,2,3]) == "Int[]");
Expect(typeof([1.0,2.0,3.0]) == "Float[]");
Expect(typeof([]) == "Any[]");
Expect(IsInstance([1,2,3], Array));
AssertEqual(typeof([0, 1, 2, 3]), "Int[]");
AssertEqual(typeof([0, 1, 2, 3][0]), "Int");
Expect(IsInstance([1, 2, 3], Array));
Expect(IsInstance([1, 2, 3], Array<Int>));

AssertEqual(typeof(1u), "UInt");
Expect(1u is UInt);
Expect(null is Object);
//io::out.Printf("typeof(null) = %\n", typeof(null));
//io::out.Printf("Number = %\n", Number);

// io console writing
io::out.WriteString("Test IO write");
io::out.WriteLine("Test IO Writeline", flush: true);
io::err.WriteString("Error message\n");
io::err.WriteLine(12345, flush: true);

// structs

my_struct := Struct.Make([["i32", "foo", 123]]);
Print("my_struct = %\n", my_struct);
Print("my_struct.foo = %\n", my_struct.Get("foo"));

let my_struct_2 = Struct.Make([["object", "StructMember", my_struct], ["i64", "num", 0xdeadbeef]]);

/*Print("my_struct_2 = %\n", my_struct_2.ToMemoryBuffer());
Print("my_struct_2 Memory Buffer = %\n", my_struct_2);
Print("my_struct_2.Get('num') == %\n", my_struct_2.Get("num"));
Expect(my_struct_2.Get("num") == 0xdeadbeef);
//Print("runtime::GetClass(my_struct_2.Get('num') == %\n", runtime::GetClass(my_struct_2.Get("num")));
Print("my_struct_2.StructMember = %\n", my_struct_2.Get("StructMember"));
my_struct_2.Set("StructMember", my_struct_2);
Expect(my_struct_2.Get("StructMember") == my_struct);

AssertEqual(GetStructMember(my_struct, "foo"), 123);*/

// test file writing

Print("new File = %\n", io::File.Open("foo.txt", "w+"));

const struct_memory = GetStructMemoryBuffer(my_struct);
Print("my_struct memory buffer = %\n", struct_memory);
const struct_memory_length = ArraySize(struct_memory);
Print("struct_memory size  = %\n", struct_memory_length);
for (let i = 0; i < struct_memory_length; i++) {
    Print("% ", struct_memory[i]);
}
Print("\n");

const foo_bar : io::File = io::File.Open("foo.bar.txt", "w+");
Expect(IsInstance(foo_bar, io::File));
Print("foo bar class base = %\n", foo_bar.class.base.name);
Print("Address 1: %, 2: %\n", GetMemoryAddress(foo_bar.class), GetMemoryAddress(io::File));
Print("Address 1: %, 2: %\n", GetMemoryAddress(foo_bar.class.base), GetMemoryAddress(io::Resource));
Expect(IsInstance(foo_bar, io::Resource));

// save Struct object to binary file
foo_bar.WriteBinary(my_struct_2);
foo_bar.Flush();
foo_bar.Close();

Expect(io::File is Class);
Expect(foo_bar is io::File);
Expect(!(foo_bar is Class));

Print("t.j = %\n", t.j);
Print("typeof(t.j) = %\n", typeof(t.j));

Expect(math::Sign<Int>(100) == 1);
Expect(math::Sign<Int>(-100) == -1);
Print("abs : %\n", math::Abs<Int>(-3434));
Expect(math::Abs<Int>(-4343) == 4343);
Expect(math::Floor<Float>(0.998) == 0.0);
Expect(math::Ceil<Float>(0.998) == 1.0);
Expect(math::PI >= 3.14 && math::PI < 3.15);

test_uint : UInt = 0u;
test_uint -= 1;
Print("test_uint = %\n", test_uint);
Print("0xFFFFFFFFu = %\n", 0xFFFFFFFFu);
Print("0u - 1 = %\n", 0u - 1);
// Expect(test_uint == 0xFFFFFFFFu);
// Expect(test_uint == ~0u);

let test_float = 200f;
Print("test_float = %\n", test_float);
Expect(test_float is Float);
Expect(test_float == 200.0);

test_vector_0 : Vector3 = new Vector3(2.0, 4.0, 6.0);
test_vector_1 : Vector3 = new Vector3(1.0, 3.0, 5.0);
test_vector_2 : Vector3 = test_vector_0 + test_vector_1;

Print("test_vector_0 = %\n", test_vector_0.ToString());
Print("test_vector_1 = %\n", test_vector_1.ToString());
Print("test_vector_2 = %\n", test_vector_2.ToString());

Expect(test_vector_2.GetX() == 3.0);
Expect(test_vector_2.GetY() == 7.0);
Expect(test_vector_2.GetZ() == 11.0);

test_vector_0 += new Vector3(1.0, 1.0, 1.0);
Expect(test_vector_0.GetX() == 3.0);
Expect(test_vector_0.GetY() == 5.0);
Expect(test_vector_0.GetZ() == 7.0);

// check operator== and operator!= work
Expect(test_vector_0 != test_vector_1);
test_vector_0 -= new Vector3(2.0, 2.0, 2.0);
Expect(test_vector_0 == test_vector_1);

// checking normalization.
// Normalized() doesn't modify the vector, but Normalize() does.
Expect(test_vector_0.Normalized().Length() > 0.999);
test_vector_0.Normalize();
Expect(test_vector_0.Length() > 0.999);

class ClassWithDefaultGenericArgs< T = Int, U = String >
{
    t: T;
    u: U;
};

Test("Generics - members being set properly", func (Unit : Function) {
    Unit("generics have members set properly when only default generic parameters are used", func () {
        test := new ClassWithDefaultGenericArgs < >;
        Print("ClassWithDefaultGenericArgs < >%\n", test);

        Expect(test.t is Int);
        Expect(test.u is String);
    });

    Unit("generics have members set properly when some generic parameters are left off", func () {
        test := new ClassWithDefaultGenericArgs < Int >;
        Print("ClassWithDefaultGenericArgs < Int >%\n", test);

        Expect(test.t is Int);
        Expect(test.u is String);
    });

    Unit("generics have members set properly when generic parameters are provided", func () {
        test := new ClassWithDefaultGenericArgs < String, Int >;
        Print("ClassWithDefaultGenericArgs < String, Int >%\n", test);

        Expect(test.t is String);
        Expect(test.u is Int);
    });

    Unit("generics have members set properly when generic parameters are provided named (in order)", func () {
        test := new ClassWithDefaultGenericArgs < T : String, U : Int >;
        Print("ClassWithDefaultGenericArgs < T : String, U : Int >%\n", test);

        Expect(test.t is String);
        Expect(test.u is Int);
    });

    Unit("generics have members set properly when generic parameters are provided named (out of order)", func () {
        test := new ClassWithDefaultGenericArgs < U : String, T : Int >;
        Print("ClassWithDefaultGenericArgs < U : String, T : Int >%\n", test);

        Expect(test.t is Int);
        Expect(test.u is String);
    });
});

func GenericFunction <T> (t : T, cond : Bool) : T
{
    return cond ? t : t - 1;
}

func GenericFunctionWithImplicitReturnType<T>(t : T, cond : Bool)
{
    return cond ? t : t - 1;
}

Test("Generic function return type", func (Unit : Function) {
    Unit("GenericFunction<Int> returns Int", func () {
        Expect(GenericFunction<Int>(5, true) is Int);
    });

    Unit("typeof GenericFunction<Int> is Function(Int, Bool) -> Int", func () {
        Expect(typeof(GenericFunction<Int>) == "Function(Int, Bool) -> Int");
    });

    Unit("typeof GenericFunction<Int>(5, true) is Int", func () {
        Expect(typeof(GenericFunction<Int>(5, true)) == "Int");
    });

    Unit("GenericFunction<Float> returns Float", func () {
        Expect(GenericFunction<Float>(5.0, true) is Float);
    });

    Unit("typeof GenericFunction<Float> is Function(Float, Bool) -> Float", func () {
        Expect(typeof(GenericFunction<Float>) == "Function(Float, Bool) -> Float");
    });

    Unit("typeof GenericFunction<Float>(5.0, true) is Float", func () {
        Expect(typeof(GenericFunction<Float>(5.0, true)) == "Float");
    });

    Unit("GenericFunctionWithImplicitReturnType<Int> returns Int", func () {
        Expect(GenericFunctionWithImplicitReturnType<Int>(5, true) is Int);
    });

    Unit("typeof GenericFunctionWithImplicitReturnType<Int> is Function(Int, Bool) -> Int", func () {
        Expect(typeof(GenericFunctionWithImplicitReturnType<Int>) == "Function(Int, Bool) -> Int");
    });

    Print("typeof(GenericFunctionWithImplicitReturnType<Int>) == %s\n", typeof(GenericFunctionWithImplicitReturnType<Int>));

    Print("Bytecode for GenericFunctionWithImplicitReturnType<Int> = %\n", GetFunctionBytecode(GenericFunctionWithImplicitReturnType<Int>));
});


func GenericFunctionWithDefault <T = Int> (t : T, cond : Bool)
{
    return cond ? t : t + 1;
}

class GenericClass<T>
{
    func DoThing(self, t : T, y : T) : T
    {
        Print("DoThing() self = %, t = %, y = %\n", self, t, y);
        return t + y;
    }
}

Test("Generic Class Methods", func (Unit : Function) {
    Unit("GenericClass<Int>.DoThing() returns Int", func () {
        test := new GenericClass<Int>();
        Expect(test.DoThing(1, 1) is Int);
    });

    Unit("GenericClass<Int>.DoThing() returns 2", func () {
        test := new GenericClass<Int>();
        Expect(test.DoThing(1, 1) == 2);
    });

    Unit("GenericClass<Float>.DoThing() returns Float", func () {
        test := new GenericClass<Float>();
        Expect(test.DoThing(1.0, 1.0) is Float);
    });

    Unit("GenericClass<Float>.DoThing() returns 2.0", func () {
        test := new GenericClass<Float>();
        Expect(test.DoThing(1.0, 1.0) == 2.0);
    });
});

class GenericClass2 <T>
{
    val : T;
}

const pi <T> : T = "hello world";
Print("pi as Float == %\n", pi<Float>, typeof(pi<Float>));
Print("pi as Int == %\n", pi<Int>, typeof(pi<Int>));


if (true) {
    Print("Test generic classes type specificiations\n");


    // try {
        const test1 = new GenericClass2<Int>();
        Expect(test1 is GenericClass2<Int>);
        // Expect(!(test1 is GenericClass2<String>));
        Expect(test1.val is Int);
        Expect(test1.val == 0);

        test2 : GenericClass2<Float> = new GenericClass2<Float>();
        Expect(test2 is GenericClass2<Float>);
        // Expect(!(test2 is GenericClass2<Int>));
        Expect(test2.val is Float);
        Expect(test2.val == 0.0);
    // } catch {
    //     Print("Caught exception\n");
    // }

    Print("After catch\n");
}

if (true) {
    Expect(GenericFunction<Float>(5.0, true) == 5.0);
    Expect(GenericFunction<Float>(5.0, false) == 4.0);
    Expect(GenericFunction<UInt>(5, true) == 5);
    Expect(GenericFunction<UInt>(5, false) == 4);
    Expect(GenericFunction<Int>(5, true) == 5);
    Expect(GenericFunction<Int>(5, false) == 4);

    const u : UInt = 5;
    Expect(u is UInt);

    Expect(GenericFunctionWithDefault<>(5, true) == 5);
    Expect(GenericFunctionWithDefault<>(5, false) == 6);
    // Expect(GenericFunctionWithDefault<>(u, true) == 5);
    // Expect(GenericFunctionWithDefault<>(u, false) == 6);
    // Expect(GenericFunctionWithDefault<>(u, true) == u);
    // Expect(GenericFunctionWithDefault<>(u, false) == u + 1);

    // $meta {
    //     // expect to break
    //     func BreakMe <T> ()
    //     {
    //         return 1;
    //     }

    //     BreakMe();
    // }
}

class ClassWithConstructor
{
    i : Int = 0;
    items : Int[];

    ClassWithConstructor(self : ClassWithConstructor, int_value : Int)
    {
        Print("This = %\n", ClassWithConstructor);
        Print("self = %\n", self);
        Print("int_value = %\n", int_value);

        self.i = int_value;
    }

    func DoThing<T>(self : ClassWithConstructor, t : T) : T
    {
        return t * 5.0;
    }

    func MakeNew(self : ClassWithConstructor, i : Int) : ClassWithConstructor
    {
        Print("self = %\n", self);

        ArrayPush(self.items, i);

        return new ClassWithConstructor(int_value : i);
    }
}

class Derived : ClassWithConstructor
{
    Derived(self : Derived)
    {
        Print("Construct derived class\n");
    }
}

func VarArgsFunc(foo : Int, args : String...)
{
    Print("in varargs function\n");

    if (foo != ArraySize(args)) {
        Print("Sizes are not equal\n");
    } else {
        Print("Sizes are equal\n");
    }

    for (i : Int = 0; i < ArraySize(args); i++) {
        Print("item : %\n", args[i]);
    }
}

class ClassWithConstMember {
    const mem : Int;
}

if (true) {
    obj : ClassWithConstMember = new ClassWithConstMember;
    Expect(obj.mem == 0);
    // should break, but doesn't
    obj.mem = 5;

    const obj2 : ClassWithConstMember = new ClassWithConstMember;
    // obj2.mem = 5; // appropriately breaks
}

if (true) {
    c := new ClassWithConstructor(int_value: 5);
    Expect(c.i == 5);

    c2 := c.MakeNew(i : 125);//ClassWithConstructor.MakeNew(i : 125);
    Print("Foo : %\n", c2.i);
    Expect(c2.i == 125);

    c3 := c.MakeNew(i : 129);//ClassWithConstructor.MakeNew(i : 125);
    Print("Foo : %\n", c3.i);
    Expect(c3.i == 129);

    const u: UInt = 4;

    Print("u = %\n", u);
    Print("typeof(u) == %\n", typeof(u));

    ary : Int[] = [1,2,3,4];
    ary[0]++;
    Expect(ary[0] == 2);

    const ary2 : Int[] = [1,2,3,4,5];
    // ary2[0]++;

    // let xx = c.DoThing<Int>;
    // Expect(xx(c, 443) == 2215);
    // Expect(c.DoThing<Int>(443) == 2215);
    // Expect(c.DoThing<Int>(443) is Int);

    Print("Items : %\n", c.items);

    Expect(ArraySize(c.items) == 2);
    Expect(c.items[0] == 125);
    Expect(c.items[1] == 129);
    Expect(c.items[1] is Int);

    let d = new Derived();
    Print("derived = %\n", d);
    Print("derived.i = %\n", d.i);
}

if (true) {
    VarArgsFunc(5, "this", "is", "a", "test");
    VarArgsFunc(4, "this", "is", "a", "test");
}

class MyObject {
    val : Int;

    // because we type it with `Function`, we are able to
    // change it to any other `Function` type later
    proc : Function = func (self : MyObject, thing : Float) {
        return self.val + thing;
    };

    // this one gets a more specific type and cannot be changed,
    // except to one with the same args
    proc2 = func (self : MyObject, thing : Float) {
        return self.val + thing;
    };

    func operator==(self : MyObject, other : MyObject) : Bool {
        return self.val == other.val;
    }

    // func operator!=(self : MyObject, other : MyObject) : Bool {
    //     return !self.operator==(other);
    // }
};

AssertEqual(typeof((new MyObject).proc), "Function");
AssertEqual(typeof((new MyObject).proc2), "Function(self: MyObject, thing: Float) -> Number");

class ClassWithGenericMember <T> {
    member : T;
};

if (true) {
    c : ClassWithGenericMember<Int> = new ClassWithGenericMember<Int>;
    Expect(c.member == 0);
    Expect(c.member is Int);

    c2 : ClassWithGenericMember<String> = new ClassWithGenericMember<String>;
    // Expect(c2.member == ""); // string compare is currently broken
    Expect(c2.member is String);
    Print("c2.member = %\n", c2.member);

    // operator overloading of ==.

    obj1 : MyObject = new MyObject;
    obj1.val = 5;

    obj2 : MyObject = new MyObject;
    obj2.val = 6;

    Expect(!(obj1 == obj2));

    obj2.val = 5;
    Expect(obj1 == obj2);

    // dynamic swapping of functions
    Expect(obj2.proc == obj1.proc);
    Expect(obj2.proc(5) == 10);
    obj2.proc = func (self: MyObject, thing : Int) {
        return self.val * thing;
    };
    Expect(obj2.proc(5) == 25);
    Expect(obj2.proc != obj1.proc);

    obj2_proc := obj2.proc;
    obj1.proc = obj2_proc;
    Expect(obj1.proc == obj2.proc);
    Expect(obj1.proc(100) == 500);

    // should work
    obj2.proc = func (self : MyObject, good : Float) {
        return null;
    };

    // should break
    // obj2.proc2 = func (self : MyObject, uhoh : Float) {
    //     return null;
    // };
}

class ClassWithToStringOverload <T = Int> {
    val : T;

    func ClassWithToStringOverload(self, val : T) {
        self.val = val;
    }

    func ToString(self) : String {
        return global::ToString(self.val);
    }
};

if (true) {
    obj : ClassWithToStringOverload<> = new ClassWithToStringOverload<>(12345);
    // Expect(obj.ToString() == "12345"); // string compare broken

    // should print: obj = 12345
    Print("obj = %\n", obj);
}

if (true) {
    // recursion

    func Recurse(times: Int) {
        if (times > 0) {
            return Recurse(times - 1);
        }

        return times;
    }

    Expect(Recurse(100) == 0);
}

// closures and captures
if (true) {
    $meta::log("Testing closures");

    //captured_var : Int = 5;

    //func Lambda(x : Int) {
    //    return captured_var * x;
    //}

    //Print("Test closures 1  %\n", Expect(Lambda(5) == 25));

    func Lambda2(x : Float) {
        return func (y : Float) {
            return x * y;
        };
    }

    $meta::log(typeof(Lambda2))
    $meta::log(typeof(Lambda2(5)))
    $meta::log(typeof(Lambda2(5)(10)))

    Print("Test closures 2  %\n", Expect(Lambda2(100)(50) == 5000));
}

// callable objects
if (true) {
    class Callable {
        i: Int;
        func $invoke(self: Callable) {
            return self.i;
        }
    }

    c : Callable = new Callable;
    c.i = 123;

    Print("Callable : %\n", Expect(c() == 123));
}

if (true) {
    Print("module.name = %\n", module.name);
    Print("module.path = %\n", module.path);
}

// dynamic module loading
// const dynamic_module = Module.Load("res/scripts/test_dynamic_module");
// Expect(dynamic_module.Get("v") == 12345);

// testing reflection
const refl_value = new Vector3();
Print("HasMember(refl_value, \"__intern\") == %\n", Expect(HasMember(refl_value, "__intern")));
Print("HasMember(refl_value, \"operator+\") == %\n", Expect(HasMember(refl_value, "operator+")));
Print("HasMember(refl_value, \"blah\") == !%\n", Expect(!HasMember(refl_value, "blah")));



// testing logical operators
if (true) {
    Print("Constant && operators\n");
    // should all be folded
    Expect(!(true && false));
    Expect(true && true);
    Expect(!(false && true));
    Expect(!(false && false));

    Print("Constant || operators\n");
    Expect(true || false);
    Expect(true || true);
    Expect(false || true);
    Expect(!(false || false));

    Print("Constant && operators (numbers)\n");
    Expect(!(1 && 0));
    Expect(4 && 6);
    Expect(!(0 && 1));
    Expect(!(0 && 0));

    Print("Constant || operators (numbers)\n");
    Expect(1 || 0);
    Expect(4 || 6);
    Expect(0 || 1);
    Expect(!(0 || 0));

    let x = 0;
    let y = 0;
    
    x = 1;
    
    Print("Dynamic && operators (numbers)\n");
    Expect(!(x && y));
    y = 1;
    Expect(x && y);
    x = 0;
    Expect(!(x && y));

    Print("Constant || operators (numbers)\n");
    Expect(x || y);
    y = 0
    Expect(!(x || y));
    x = 1;
    Expect(x || y);
    y = 1;
    Expect(x || y);
}

// // alias testing
// if (true) {
//     x : Int = 5;
//     alias y = x;
//     y++;
//     Expect(x == 6);
//     Expect(y == 6);

//     const x1 : Int = 5;
//     alias y1 = x;
//     y1++; // should break

//     alias Z = ClassWithToStringOverload<Int>;
//     z : Z = new Z();
//     Print("z = %\n", z);
//     // Expect(z is ClassWithToStringOverload)
// }

// test references
Test("Ref function parameters", func (Unit : Function) {
    func DoNotModifyReference(j : Int) {
        j++;
    }

    func ModifyReference(ref j : Int, k : Float) {
        j++;
        k++;
    }
    
    func PassConstReference(const ref x : Int) {
        // illegal
        //x++;

        Print("const ref passed: %\n", x);
    }

    Unit("Can pass any value to a non-ref parameter", func () {
        x : Int = 5;
        DoNotModifyReference(x);
        Expect(x == 5);
    });

    Unit("Modifying ref of x modifes the original var", func () {
        x : Int = 5;
        ref y : Int = x;
        y++;

        Expect(x == 6);
        Expect(y == 6);
    });

    Unit("Can pass ref to a function", func () {
        x : Int = 5;
        ref y : Int = x;
        y++;

        ModifyReference(x, y);

        Expect(x == 7);
        Expect(y == 7);
    });

    Unit("Cannot modify a constant", func () {
        const const_var : Int = 123;

        // legal
        PassConstReference(const_var);
        Print("const_var = %\n", const_var);

        Expect(const_var == 123);

        // illegal
        // ModifyReference(const_var, 5);
    });
});

import containers::Stack;

if (true) {
    // test container
    stk : Stack<Float> = new Stack<Float>;

    stk.Push(5.0f);
    Expect(stk.Top() == 5.0f);
    stk.Push(6.0f);
    Expect(stk.Top() == 6.0f);
    Expect(stk.Pop() == 6.0f);
    Expect(stk.Top() == 5.0f);
    stk.Pop();
    Expect(stk.Size() == 0);
    Expect(stk.Empty());
}

// class Iterator <T> {
//     stk : Stack<T> = new Stack<T>;
//     index : Int = 0;

//     Iterator(self, stk : Any, index : Int = 0)
//     {
//         self.stk = stk;
//         self.index = index;
//     }

//     func operator+=(self, amount : Int)
//     {
//         self.index += amount;

//         return self;
//     }

//     func Value(self) : T
//     {
//         return self.stk.ary[self.index];
//     }
// }

// stk : Stack<Int> = new Stack<Int>();
// stk.Push(1);
// stk.Push(2);

// let iter : Iterator<Int> = new Iterator<Int>(stk);
// Print("iter.Value() = %\n", iter.Value());
// iter++;
// Print("iter.Value() = %\n", iter.Value());

// let iter2 : Iterator<Int> = new Iterator<Int>(new Stack<Float>());

Test("Array types", func (Unit : Function) {
    Unit("Empty array type is Any[]", func () {
        AssertEqual(typeof([]), "Any[]");
    });

    Unit("[1,2,3] has type Int[]", func () {
        AssertEqual(typeof([1,2,3]), "Int[]");
    });

    Unit("[1,2,3.0] has type Number[]", func () {
        AssertEqual(typeof([1,2,3.0]), "Number[]");
    });

    Unit("[1,2,3,null] has type Any[]", func () {
        AssertEqual(typeof([1,2,3,null]), "Any[]");
    });

    Unit("Generic types fall to common type", func () {
        AssertEqual(typeof([func (x : String) {}, func (y : Float) {}]), "Function[]");
    });
});

Test("Prefix and postfix ++ operators", func (Unit : Function) {
    Unit("Check postfix ++ returns original value", func () {
        i : Int = 0;
        AssertEqual(i++, 0);
        AssertEqual(i, 1);
    });

    Unit("Check prefix ++ returns modified value", func () {
        i : Int = 0;
        AssertEqual(++i, 1);
        AssertEqual(i, 1);
    });

    Unit("Check += returns modified value", func () {
        i : Int = 0;
        AssertEqual(i += 1, 1);
        AssertEqual(i, 1);
    });
});

// Print("typeof(iter2) = %\n", typeof(iter2));
// Print("typeof(new Stack<String>) = %\n", typeof(new Stack<String>));
// Print("typeof(iter2.stk) = %\n", typeof(iter2.stk));
// Print("typeof(Stack<String>) = %\n", typeof(Stack<String>));

func f1(a : Float, b : Int, blah = "test")
{
    return func (g : Float, h : Int) {
        return a + g * h;
    }
}

Print("typeof(f1) = %\n", typeof(f1));
Print("typeof(f1(1, 2)) == %\n", typeof(f1(1, 2)));
Print("f1(1, 2) == %\n", f1(1, 2));
Print("f1(1, 2)(3, 4) == %\n", f1(1, 2)(3, 4));
// Print("typeof(Stack<Int, Float>) = %\n", typeof(Stack<Int>));

class NewGenericClass <T> {
    x : T;

    NewGenericClass(self) {
        let y : T;
        Print("self.x == %\n", self.x);
        Print("typeof(self.x) == %\n", typeof(self.x));
        Print("T = %\n", T);
        Print("typeof(T) = %\n", typeof(T));
        Print("y = %\n", y);
        Print("typeof(y) == %\n", typeof(y));
    }

    func AddOne(self : Any, num : T)
    {
        return self.x + num;
    }
}

let new_generic : NewGenericClass<String> = new NewGenericClass<String>;
let new_generic2 : NewGenericClass<Int> = new NewGenericClass<Int>;
let Blah = Int;
Print("typeof(Blah) = %\n", typeof(Blah));
Print("Blah = %\n", Blah);
let g : Blah = 5;
Print("typeof(g) == %\n", typeof(g));
Print("typeof(new_generic.x) = %\n", typeof(new_generic.x));
Print("typeof(new_generic2.x) = %\n", typeof(new_generic2.x));
Print("typeof(new_generic.AddOne) == %\n", typeof(new_generic.AddOne));
Print("typeof(new_generi2.AddOne) == %\n", typeof(new_generic2.AddOne));

class ExtendedVector3 : Vector3
{
    func Print(self : ExtendedVector3)
    {
        io::out.WriteString("Vector3 print function\n");
        Print("self = %   x = %\n", self); // self.GetX() or any Vector3 member functions break
    }
}

let extended_vector3 = new ExtendedVector3;
extended_vector3.Print();
//Print("extended_vector3.x = %\n", extended_vector3.x);

const mesh = new Mesh();
Print("mesh.NumIndices() = %\n", mesh.NumIndices());

let vertex: Vertex = new Vertex();
Print("vertex.GetPosition() = %\n", vertex.GetPosition().ToString());
vertex.SetPosition(new Vector3(1, 2, 3));
AssertEqual(vertex.GetPosition(), new Vector3(1, 2, 3));
vertex.SetBoneIndex(0, 1);
AssertEqual(vertex.GetBoneIndex(0), 1);

let vertices : Vertex[] = [];
for (let i = 0; i < 100; i++) {
    let v = new Vertex();
    v.SetPosition(new Vector3(0, 10, i));
    ArrayPush(vertices, v);
}

AssertEqual(vertices[0].GetPosition(), new Vector3(0, 10, 0));
AssertEqual(vertices[99].GetPosition(), new Vector3(0, 10, 99));
//AssertEqual(vertices[100].GetPosition(), new Vector3(0, 10, 100)); // break

mesh.SetVertices(vertices);
Print("Num Vertices : %\n", mesh.NumVertices());
mesh.Init();

let entity_1 = new Entity();
entity_1.SetMesh(mesh);
entity_1.Init();
Print("entity_1.GetMesh() = %\n", entity_1.GetMesh());
Expect(entity_1.GetMesh().GetID() == mesh.GetID());

let material = new Material();
entity_1.SetMaterial(material);

Print("entity_1.GetMaterial().GetID() = %\n", entity_1.GetMaterial().GetID());

Print("Tex: %", material.GetTextureAtIndex(0));


enum UIEventType {
    NONE,

    MOUSE_DOWN,
    MOUSE_UP,
    MOUSE_DRAG,
    MOUSE_HOVER
}

class TestUIController : Controller
{
    click_position : Vector2 = new Vector2();
    entity : EntityProxy = null;

    TestUIController(self : TestUIController)
    {
        Print("TestUIController = %\n", TestUIController);
        Print("TestUIController.base = %\n", TestUIController.base);
        Print("self.class = %\n", self.class);
        Print("self.class.base = %\n", self.class.base);
        Print("self.class.name = %\n", self.class.name);

        self.receives_update = false;
    }

    func OnAdded(self : TestUIController, entity : EntityProxy)
    {
        self.entity = entity;
    }

    func OnRemoved(self : TestUIController)
    {
        self.entity = null;
    }

    func OnTick(self : TestUIController, delta : Float)
    {
        Print("Tick UI Component\n")
    }

    func OnEvent(self : TestUIController, event_type : Int, mouse_position : Vector2)
    {
        const entity_position : Vector3 = self.entity.GetTranslation();
        const aabb : BoundingBox = self.entity.GetWorldAABB();
        const min = aabb.GetMin();
        const max = aabb.GetMax();

        const center : Vector3 = (max + min) * new Vector3(0.5, 0.5, 0.5);

        if (event_type == UIEventType.MOUSE_DOWN) {
            self.click_position = new Vector2(mouse_position.GetX() - entity_position.GetX(), mouse_position.GetY() - entity_position.GetY());

            //let ent : EntityProxy = engine::CreateEntity();
            //ent.SetTranslation(new Vector3(0, 20, 0));
            //Print("ent.GetWorldAABB() = %\n", ent.GetWorldAABB());

        } else if (event_type == UIEventType.MOUSE_UP) {
            self.click_position = new Vector2(0.0, 0.0);
        } else if (event_type == UIEventType.MOUSE_DRAG) {
            self.entity.SetTranslation(new Vector3(mouse_position.GetX() + self.click_position.GetX(), mouse_position.GetY() + self.click_position.GetY()/*(mouse_position.GetY() - (1.0 - self.click_position.GetY()))*/, 0.0));
        }

        Print("world AABB = %\n", self.entity.GetWorldAABB());
    }
};

export const controller = new TestUIController;
