
#version 450

#extension GL_GOOGLE_include_directive : require

#define WORKGROUP_SIZE 32

layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE) in;

#define HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

#include "../include/defines.inc"
#include "../include/shared.inc"
#include "../include/noise.inc"
#include "../include/packing.inc"
#include "../include/env_probe.inc"
#include "../include/scene.inc"
#include "../include/Octahedron.glsl"
#include "../include/brdf.inc"

HYP_DESCRIPTOR_SRV(LightFieldProbeDescriptorSet, InColorImage) uniform textureCube color_texture;
HYP_DESCRIPTOR_SRV(LightFieldProbeDescriptorSet, InNormalsImage) uniform textureCube normals_texture;
HYP_DESCRIPTOR_SRV(LightFieldProbeDescriptorSet, InDepthImage) uniform textureCube depth_texture;

HYP_DESCRIPTOR_SAMPLER(LightFieldProbeDescriptorSet, SamplerLinear) uniform sampler sampler_linear;
HYP_DESCRIPTOR_SAMPLER(LightFieldProbeDescriptorSet, SamplerNearest) uniform sampler sampler_nearest;

HYP_DESCRIPTOR_UAV(LightFieldProbeDescriptorSet, OutColorImage, format = rgba8) uniform image2D out_color_image;
HYP_DESCRIPTOR_UAV(LightFieldProbeDescriptorSet, OutDepthsImage, format = rg16f) uniform image2D out_depths_image;

HYP_DESCRIPTOR_CBUFF(LightFieldProbeDescriptorSet, UniformBuffer) uniform UniformBuffer
{
    uvec4 image_dimensions;
    uvec4 probe_grid_position;
    uvec4 dimension_per_probe;
    uvec4 probe_offset_coord;

    uint  num_bound_lights;
    uint  _pad0;
    uint  _pad1;
    uint  _pad2;

    uvec4 light_indices[4];
};

HYP_DESCRIPTOR_SRV(Scene, EnvProbeTextures, count = 16) uniform textureCube env_probe_textures[16];
HYP_DESCRIPTOR_SSBO(Scene, EnvProbesBuffer, size = 131072) readonly buffer EnvProbesBuffer { EnvProbe env_probes[HYP_MAX_ENV_PROBES]; };
HYP_DESCRIPTOR_SSBO(Scene, SHGridBuffer, size = 147456) readonly buffer SHGridBuffer { vec4 sh_grid_buffer[SH_GRID_BUFFER_SIZE]; };
HYP_DESCRIPTOR_SSBO_DYNAMIC(Scene, CurrentEnvProbe, size = 512) readonly buffer CurrentEnvProbe { EnvProbe current_env_probe; };

HYP_DESCRIPTOR_SSBO(Scene, LightsBuffer) readonly buffer LightsBuffer { Light lights[]; };

vec2 NormalizeOctahedralCoord(uvec2 local_coord)
{
    return (vec2(local_coord) + vec2(0.5)) * (vec2(2.0) / vec2(dimension_per_probe)) - vec2(1.0);
}

struct ConvolveResult
{
    vec4 color;
    vec2 dist_dist2;
};

vec4 SampleSky(vec3 dir)
{
    if (current_env_probe.texture_index != ~0u) {
        uint probe_texture_index = max(0, min(current_env_probe.texture_index, HYP_MAX_BOUND_REFLECTION_PROBES - 1));

        return TextureCube(sampler_linear, env_probe_textures[probe_texture_index], dir);
    }

    return vec4(0.0);
}

vec4 CalculateDirectLighting(uint light_index, in vec4 albedo, in vec3 P, in vec3 N, in vec3 V)
{
    if (lights[light_index].type != HYP_LIGHT_TYPE_DIRECTIONAL) {
        return vec4(0.0);
    }

    const vec4 light_color = vec4(UINT_TO_VEC4(lights[light_index].color_encoded).rgb, 1.0);

    vec3 L = normalize(lights[light_index].position_intensity.xyz);

    float NdotL = max(0.0001, dot(N, L));

    return albedo * min(NdotL, 0.2);
}

ConvolveResult ConvoleProbe(uvec2 local_coord)
{
    const int num_samples = 1024;
    const float lobe_size = 0.95;

    const vec2 oct_coord = NormalizeOctahedralCoord(local_coord);
    const vec3 dir = -DecodeOctahedralCoord(oct_coord);

    vec4 sum_radiance = vec4(0.0);
    vec2 sum_distance = vec2(0.0);

    uint seed = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * 1000 + probe_grid_position.w * 1000000;

    const uint face_index = GetCubemapFaceIndex(dir);
    vec3 face_normal = GetCubemapCoord(face_index, vec2(0.0));

    for (int i = 0; i < num_samples; i++) {
        vec3 offset = RandomInSphere(vec3(RandomFloat(seed), RandomFloat(seed), RandomFloat(seed)));
        vec3 sample_dir = normalize(dir + vec3(lobe_size) * offset);

        vec4 sky = SampleSky(sample_dir);

        vec3 normal = normalize(UnpackNormalVec2(TextureCube(sampler_linear, normals_texture, sample_dir).rg));

        vec2 dist_dist2 = TextureCube(sampler_linear, depth_texture, sample_dir).rg;
        sum_distance += dist_dist2;

        vec4 position = vec4(env_probes[probe_grid_position.w].world_position.xyz + sample_dir * dist_dist2.r, 1.0);

        vec4 albedo = TextureCube(sampler_linear, color_texture, sample_dir);

        vec4 radiance = vec4(0.0);
        
        for (uint j = 0; j < num_bound_lights; j++) {
            uint light_index = light_indices[j / 4][j % 4];

            radiance += CalculateDirectLighting(light_index, albedo, position.xyz, normal, -sample_dir);
        }

        radiance = mix(radiance, sky, step(HYP_FLOAT_MAX, dist_dist2.r));
        sum_radiance += radiance;
    }

    ConvolveResult result;
    result.color = sum_radiance / float(num_samples);
    result.dist_dist2 = sum_distance / float(num_samples);

    return result;
}

void main(void)
{
    const uvec2 local_coord = uvec2(gl_GlobalInvocationID.xy);

    if (any(greaterThanEqual(local_coord, dimension_per_probe.xy))) {
        return;
    }

    ConvolveResult convolve_result = ConvoleProbe(local_coord);

    const uvec2 coord = probe_offset_coord.xy + local_coord;

    imageStore(out_color_image, ivec2(coord), convolve_result.color);
    imageStore(out_depths_image, ivec2(coord), vec4(convolve_result.dist_dist2, 0.0, 1.0));
    // imageStore(out_image, ivec2(coord), vec4(vec3(probe_grid_position.xyz) / vec3(6, 4, 6), 1.0));// convolve_result.color);
}