#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_scalar_block_layout : require

#include "../../include/defines.inc"
#include "../../include/noise.inc"
#include "../../include/packing.inc"

#ifdef HYP_FEATURES_DYNAMIC_DESCRIPTOR_INDEXING
HYP_DESCRIPTOR_SRV(View, GBufferTextures, count = 7) uniform texture2D gbuffer_textures[NUM_GBUFFER_TEXTURES];
#else
HYP_DESCRIPTOR_SRV(View, GBufferAlbedoTexture) uniform texture2D gbuffer_albedo_texture;
HYP_DESCRIPTOR_SRV(View, GBufferNormalsTexture) uniform texture2D gbuffer_normals_texture;
HYP_DESCRIPTOR_SRV(View, GBufferMaterialTexture) uniform utexture2D gbuffer_material_texture;
HYP_DESCRIPTOR_SRV(View, GBufferVelocityTexture) uniform texture2D gbuffer_velocity_texture;
HYP_DESCRIPTOR_SRV(View, GBufferLightmapTexture) uniform texture2D gbuffer_albedo_lightmap_texture;
HYP_DESCRIPTOR_SRV(View, GBufferWSNormalsTexture) uniform texture2D gbuffer_ws_normals_texture;
HYP_DESCRIPTOR_SRV(View, GBufferTranslucentTexture) uniform texture2D gbuffer_albedo_texture_translucent;
#endif

HYP_DESCRIPTOR_SRV(View, GBufferMipChain) uniform texture2D gbuffer_mip_chain;
HYP_DESCRIPTOR_SRV(View, GBufferDepthTexture) uniform texture2D gbuffer_depth_texture;

HYP_DESCRIPTOR_SRV(Global, PointLightShadowMapsTextureArray) uniform textureCubeArray point_shadow_maps;

HYP_DESCRIPTOR_SAMPLER(Global, SamplerNearest) uniform sampler sampler_nearest;
HYP_DESCRIPTOR_SAMPLER(Global, SamplerLinear) uniform sampler sampler_linear;

#define texture_sampler sampler_linear
#define HYP_SAMPLER_NEAREST sampler_nearest
#define HYP_SAMPLER_LINEAR sampler_linear

HYP_DESCRIPTOR_ACCELERATION_STRUCTURE(RTRadianceDescriptorSet, TLAS) uniform accelerationStructureEXT tlas;
HYP_DESCRIPTOR_UAV(RTRadianceDescriptorSet, OutputImage, format = rgba8) uniform image2D image;

#define HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

#include "../../include/gbuffer.inc"
#include "../../include/scene.inc"
#include "../../include/shared.inc"
#include "../../include/packing.inc"
#include "../../include/noise.inc"
#include "../../include/brdf.inc"
#include "../../include/env_probe.inc"

/// Blue noise
HYP_DESCRIPTOR_SSBO(Global, BlueNoiseBuffer) readonly buffer BlueNoiseBuffer
{
	ivec4 sobol_256spp_256d[256 * 256 / 4];
	ivec4 scrambling_tile[128 * 128 * 8 / 4];
	ivec4 ranking_tile[128 * 128 * 8 / 4];
};

#include "../../include/BlueNoise.glsl"

#undef HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

HYP_DESCRIPTOR_SSBO(Global, LightsBuffer) readonly buffer LightsBuffer
{
    Light lights[];
};

HYP_DESCRIPTOR_CBUFF(Global, WorldsBuffer) uniform WorldsBuffer
{
    WorldShaderData world_shader_data;
};

HYP_DESCRIPTOR_CBUFF_DYNAMIC(Global, CamerasBuffer) uniform CameraShaderData
{
    Camera camera;
};

HYP_DESCRIPTOR_SRV(Global, EnvProbeTextures, count = 16) uniform texture2D env_probe_textures[16];
HYP_DESCRIPTOR_SSBO(Global, EnvProbesBuffer) readonly buffer EnvProbesBuffer { EnvProbe env_probes[]; };
HYP_DESCRIPTOR_CBUFF_DYNAMIC(Global, EnvGridsBuffer) uniform EnvGridsBuffer { EnvGrid env_grid; };
HYP_DESCRIPTOR_SSBO_DYNAMIC(Global, CurrentEnvProbe) readonly buffer CurrentEnvProbe { EnvProbe current_env_probe; };

#include "../../include/Octahedron.glsl"

#define PATHTRACER
#include "../../include/rt/RTRadiance.inc"
#include "../../include/rt/payload.inc"

HYP_DESCRIPTOR_CBUFF(RTRadianceDescriptorSet, RTRadianceUniforms) uniform RTRadianceUniformBuffer
{
    RTRadianceUniforms rt_radiance_uniforms;
};

layout(location = 0) rayPayloadEXT RayPayload payload;

#define RAY_OFFSET 0.001
#define NUM_SAMPLES 2
#define NUM_BOUNCES 8

struct RayBounceInfo
{
    vec4 throughput;
    vec4 emissive;
    vec4 radiance; // set in 2nd pass
};

float CheckInShadow(vec3 position, vec3 normal, vec3 lightDir)
{
    vec3 origin = position + normal * 0.01;
    vec3 direction = lightDir;

    rayQueryEXT rq;
    rayQueryInitializeEXT(rq, tlas,
        gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT,
        0xff, origin, 0.0001, direction, 1000.0);

    rayQueryProceedEXT(rq);

    return float(rayQueryGetIntersectionTypeEXT(rq, true) != gl_RayQueryCommittedIntersectionNoneEXT);
}

void BuildONB(in vec3 n, out vec3 t, out vec3 b)
{
    float sign = n.z >= 0.0 ? 1.0 : -1.0;
    float a = -1.0 / (sign + n.z);
    float bxy = n.x * n.y * a;
    t = vec3(1.0 + sign * n.x * n.x * a, sign * bxy, -sign * n.x);
    b = vec3(bxy, sign + n.y * n.y * a, -n.y);
}

vec2 ConcentricDisk(vec2 u)
{
    float sx = 2.0 * u.x - 1.0;
    float sy = 2.0 * u.y - 1.0;
    if (sx == 0.0 && sy == 0.0) return vec2(0.0);
    float r, theta;
    if (abs(sx) > abs(sy))
    {
        r = abs(sx);
        theta = (HYP_FMATH_PI * 0.25) * (sy / sx);
    }
    else
    {
        r = abs(sy);
        theta = (HYP_FMATH_PI * 0.5) - (HYP_FMATH_PI * 0.25) * (sx / sy);
    }
    return r * vec2(cos(theta), sin(theta));
}

void SpinFrame(inout vec3 t, inout vec3 b, float angle)
{
    float s = sin(angle), c = cos(angle);
    vec3 t0 = t;
    t =  c * t0 + s * b;
    b = -s * t0 + c * b;
}

vec3 radiance = vec3(0.0);
vec3 beta = vec3(1.0);

vec3 SampleGGX(vec2 xi, float roughness, vec3 N)
{
    float a = roughness * roughness;
    
    // Sample in polar coordinates
    float phi = 2.0 * HYP_FMATH_PI * xi.x;
    float cosTheta = sqrt((1.0 - xi.y) / (1.0 + (a*a - 1.0) * xi.y));
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    
    // Convert to cartesian
    vec3 H;
    H.x = sinTheta * cos(phi);
    H.y = sinTheta * sin(phi);
    H.z = cosTheta;
    
    // Transform to world space
    vec3 T1, T2;
    ComputeOrthonormalBasis(N, T1, T2);
    return normalize(T1 * H.x + T2 * H.y + N * H.z);
}

float GGX_PDF(float NdotH, float HdotV, float roughness)
{
    float a = roughness * roughness;
    float a2 = a * a;
    float D = a2 / (HYP_FMATH_PI * pow(NdotH * NdotH * (a2 - 1.0) + 1.0, 2.0));
    return (D * NdotH) / (4.0 * HdotV);
}

vec3 F_Schlick(vec3 f0, float cosTheta)
{
    return f0 + (1.0 - f0) * pow(1.0 - cosTheta, 5.0);
}

void main() 
{
    const ivec2 resolution = rt_radiance_uniforms.output_image_resolution;
    
    const int pixel_index = int(gl_LaunchIDEXT.x * 2) + int(world_shader_data.frame_counter & 1);
    const ivec2 storage_coord = ivec2(
        pixel_index % resolution.x,
        pixel_index / resolution.x
    );

    if (pixel_index >= resolution.x * resolution.y)
    {
        // Out of bounds; return
        return;
    }

    const vec2 uv = (vec2(storage_coord) + 0.5) / vec2(resolution);

    const mat4 view_inverse = inverse(camera.view);
    const mat4 projection_inverse = inverse(camera.projection);

    const vec3 normal = normalize(DecodeNormal(Texture2DLod(sampler_nearest, gbuffer_normals_texture, uv, 0.0)));
    const float depth = Texture2DLod(sampler_nearest, gbuffer_depth_texture, uv, 0.0).r;
    const vec4 worldPosition = ReconstructWorldSpacePositionFromDepth(projection_inverse, view_inverse, uv, depth);

    uvec2 materialData = texture(usampler2D(gbuffer_material_texture, HYP_SAMPLER_NEAREST), uv).rg;

    GBufferMaterialParams materialParams;
    GBufferUnpackMaterialParams(materialData, materialParams);

    const float roughness = materialParams.roughness;
    const float metalness = materialParams.metalness;

    const vec3 V = normalize(camera.position.xyz - worldPosition.xyz);
    const vec3 R = reflect(-V, normal);

    const uint flags = gl_RayFlagsOpaqueEXT;
    const uint mask = 0xff;
    const float tmin = 0.001;
    const float tmax = 1000.0;

    vec4 color = vec4(0.0);

    const vec3 albedo = Texture2DLod(sampler_nearest, gbuffer_albedo_texture, uv, 0.0).rgb;
    const vec3 N0 = normalize(normal);

    vec3 tangent;
    vec3 bitangent;

    vec4 accumRadiance = vec4(0.0);

    for (uint sample_index = 0; sample_index < NUM_SAMPLES; sample_index++)
    {
        uint ray_seed = InitRandomSeed(InitRandomSeed(
            (gl_LaunchIDEXT.x * 2 * NUM_SAMPLES) + sample_index * 2,
            (gl_LaunchIDEXT.x * 2 * NUM_SAMPLES) + (sample_index * 2) + 1),
            world_shader_data.frame_counter % 256);

        vec3 origin = worldPosition.xyz + N0 * RAY_OFFSET;

        vec3 direction;
        vec2 rnd = vec2(RandomFloat(ray_seed), RandomFloat(ray_seed));

        direction = SampleCosineDir(rnd, N0);

        vec3 radiance = vec3(0.0);
        vec3 beta = vec3(1.0);
        
        // Store view direction for specular calculations
        vec3 viewDir = normalize(camera.position.xyz - worldPosition.xyz);

        for (int bounceIndex = 0; bounceIndex < NUM_BOUNCES; ++bounceIndex) {
            // perform scene trace using global payload
            payload.distance = -1.0;
            payload.throughput = vec4(1.0);
            payload.emissive = vec4(0.0);
            payload.normal = vec3(0.0);

            traceRayEXT(tlas, flags, mask, 0, 0, 0, origin, tmin, direction, tmax, 0);

            if (payload.distance < 0.0) {
                // miss -> sample environment probe if present
                if (current_env_probe.texture_index != ~0u) {
                    uint probe_texture_index = max(0, min(current_env_probe.texture_index, HYP_MAX_BOUND_REFLECTION_PROBES - 1));
                    vec3 env = Texture2D(sampler_linear, env_probe_textures[probe_texture_index], EncodeOctahedralCoord(normalize(direction)) * 0.5 + 0.5).rgb;
                    radiance += beta * env;
                }
                break;
            }

            vec3 hitPos = origin + direction * payload.distance;
            vec3 N = normalize(payload.normal);

            // emissive
            if (length(payload.emissive.rgb) > 0.0) {
                radiance += beta * payload.emissive.rgb;
            }

            // Calculate material properties - using albedo from the hit point
            vec3 diffuseColor = albedo * (1.0 - metalness);
            vec3 f0 = mix(vec3(0.04), albedo, metalness);

            beta *= diffuseColor * HYP_FMATH_ONE_OVER_PI;
            
            // Process light contributions
            for (uint light_index = 0; light_index < rt_radiance_uniforms.num_bound_lights; light_index++) {
                const Light light = HYP_GET_LIGHT(light_index);
                vec3 light_color = UINT_TO_VEC4(light.color_encoded).rgb * light.position_intensity.w;

                if (light.type == HYP_LIGHT_TYPE_DIRECTIONAL) {
                    vec3 light_direction = normalize(light.position_intensity.xyz);
                    vec3 L = light_direction;

                    // shadow check
                    float shadow = 1.0 - CheckInShadow(hitPos, N, L);
                    if (shadow > 0.0) {
                        float NdotL = max(dot(N, L), 0.0);
                        
                        // Add specular term
                        vec3 H = normalize(direction + L);
                        float NdotH = max(dot(N, H), 0.0);
                        float HdotV = max(dot(H, direction), 0.0);
                        float NdotV = max(dot(N, V), 0.0);
                        
                        // Calculate fresnel
                        vec3 F = F_Schlick(f0, HdotV);
                        
                        // Geometric term
                        float G = V_SmithGGXCorrelated(roughness, NdotV, NdotL);

                        // Distribution term
                        float D = GGX_PDF(NdotH, HdotV, roughness);
                        
                        // Add both diffuse and specular components
                        radiance += beta * shadow * light_color * (
                            diffuseColor * NdotL * HYP_FMATH_ONE_OVER_PI +  // Diffuse
                            F * G * D * NdotL                               // Specular
                        );
                    }
                } else if (light.type == HYP_LIGHT_TYPE_POINT) {
                    vec3 L = normalize(light.position_intensity.xyz - hitPos);
                    float d = length(light.position_intensity.xyz - hitPos);
                    float attenuation = 1.0 / (d * d);

                    float NdotL = max(dot(N, L), 0.0);
                    
                    // Add specular term
                    vec3 H = normalize(direction + L);
                    float NdotH = max(dot(N, H), 0.0);
                    float HdotV = max(dot(H, direction), 0.0);
                    float NdotV = max(dot(N, V), 0.0);
                    
                    // Calculate fresnel
                    vec3 F = F_Schlick(f0, HdotV);

                    // Geometric term
                    float G = V_SmithGGXCorrelated(roughness, NdotV, NdotL);

                    // Distribution term
                    float D = GGX_PDF(NdotH, HdotV, roughness);
                    
                    radiance += beta * light_color * attenuation * (
                        diffuseColor * NdotL * HYP_FMATH_ONE_OVER_PI +  // Diffuse
                        F * G * D * NdotL                               // Specular
                    );
                } else {
                    /// ... TODO
                }
            }

            if (bounceIndex >= 3) {
                float p = clamp(max(max(beta.r, beta.g), beta.b), 0.05, 0.99);
                if (RandomFloat(ray_seed) > p) {
                    break;
                }
                beta /= vec3(p);
            }



            rnd = vec2(RandomFloat(ray_seed), RandomFloat(ray_seed));

            direction = normalize(SampleCosineDir(rnd, N));
            origin = hitPos + N * RAY_OFFSET;
        } // end bounces

        accumRadiance.rgb += radiance;
    } // end samples


    vec3 finalColor = accumRadiance.rgb / float(NUM_SAMPLES);

    // // // test
    // float inShadow = 1.0-CheckInShadow(ray.origin.xyz, ray.direction.xyz, HYP_GET_LIGHT(0).position_intensity.xyz);
    // vec3 Normal = normalize(ray.direction.xyz);
    // vec3 LightDir = normalize(HYP_GET_LIGHT(0).position_intensity.xyz);
    // vec3 NoL = max(dot(Normal, LightDir), 0.0) * vec3(1.0);
    // finalColor = NoL * inShadow;

    // // DEBUG : return first hit normal
    // finalColor = DebugTest_Albedo(ray.origin.xyz, N0);

    imageStore(image, storage_coord, vec4(finalColor, 1.0));
}
