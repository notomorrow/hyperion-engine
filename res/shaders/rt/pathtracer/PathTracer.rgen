#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

#include "../../include/defines.inc"
#include "../../include/noise.inc"
#include "../../include/packing.inc"
#include "../../include/tonemap.inc"

HYP_DESCRIPTOR_SRV(Global, GBufferTextures, count = 8) uniform texture2D gbuffer_textures[8];
HYP_DESCRIPTOR_SRV(Global, GBufferMipChain) uniform texture2D gbuffer_mip_chain;
HYP_DESCRIPTOR_SRV(Global, GBufferDepthTexture) uniform texture2D gbuffer_depth_texture;

HYP_DESCRIPTOR_SAMPLER(Global, SamplerNearest) uniform sampler sampler_nearest;
HYP_DESCRIPTOR_SAMPLER(Global, SamplerLinear) uniform sampler sampler_linear;

#define texture_sampler sampler_linear
#define HYP_SAMPLER_NEAREST sampler_nearest
#define HYP_SAMPLER_LINEAR sampler_linear

HYP_DESCRIPTOR_ACCELERATION_STRUCTURE(RTRadianceDescriptorSet, TLAS) uniform accelerationStructureEXT tlas;
HYP_DESCRIPTOR_UAV(RTRadianceDescriptorSet, OutputImage, format = rgba8) uniform image2D image;

#define HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

#include "../../include/gbuffer.inc"
#include "../../include/scene.inc"
#include "../../include/shared.inc"
#include "../../include/packing.inc"
#include "../../include/noise.inc"
#include "../../include/brdf.inc"
#include "../../include/env_probe.inc"

/// Blue noise
HYP_DESCRIPTOR_SSBO(Global, BlueNoiseBuffer, size = 1310720) readonly buffer BlueNoiseBuffer
{
	ivec4 sobol_256spp_256d[256 * 256 / 4];
	ivec4 scrambling_tile[128 * 128 * 8 / 4];
	ivec4 ranking_tile[128 * 128 * 8 / 4];
};

#include "../../include/BlueNoise.glsl"

#undef HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

HYP_DESCRIPTOR_SSBO(RTRadianceDescriptorSet, LightsBuffer) readonly buffer LightsBuffer
{
    Light lights[];
};

HYP_DESCRIPTOR_SSBO_DYNAMIC(Scene, ScenesBuffer, size = 256) readonly buffer SceneBuffer
{
    Scene scene;
};

HYP_DESCRIPTOR_CBUFF_DYNAMIC(Scene, CamerasBuffer, size = 512) uniform CameraShaderData
{
    Camera camera;
};

HYP_DESCRIPTOR_SRV(Scene, EnvProbeTextures, count = 16) uniform textureCube env_probe_textures[16];
HYP_DESCRIPTOR_SSBO(Scene, EnvProbesBuffer, size = 131072) readonly buffer EnvProbesBuffer { EnvProbe env_probes[HYP_MAX_ENV_PROBES]; };
HYP_DESCRIPTOR_CBUFF_DYNAMIC(Scene, EnvGridsBuffer, size = 4352) uniform EnvGridsBuffer { EnvGrid env_grid; };
HYP_DESCRIPTOR_SSBO(Scene, SHGridBuffer, size = 147456) readonly buffer SHGridBuffer { vec4 sh_grid_buffer[SH_GRID_BUFFER_SIZE]; };
HYP_DESCRIPTOR_SSBO_DYNAMIC(Scene, CurrentEnvProbe, size = 512) readonly buffer CurrentEnvProbe
{
    EnvProbe current_env_probe;
};

#define PATHTRACER
#include "../../include/rt/RTRadiance.inc"
#include "../../include/rt/payload.inc"

HYP_DESCRIPTOR_CBUFF(RTRadianceDescriptorSet, RTRadianceUniforms) uniform RTRadianceUniformBuffer
{
    RTRadianceUniforms rt_radiance_uniforms;
};

layout(location = 0) rayPayloadEXT RayPayload payload;

#define RAY_OFFSET 0.01
#define NUM_SAMPLES 8
#define NUM_BOUNCES 2

void main() 
{
    const ivec2 resolution = imageSize(image);
    
    const int pixel_index = int(gl_LaunchIDEXT.x * 2) + int(scene.frame_counter & 1);
    const ivec2 storage_coord = ivec2(
        pixel_index % resolution.x,
        pixel_index / resolution.x
    );

    //if (pixel_index % 2 == 0) {
    //    return;
    //}

    const vec2 uv = (vec2(storage_coord) + 0.5) / vec2(resolution);

    const mat4 view_inverse = inverse(camera.view);
    const mat4 projection_inverse = inverse(camera.projection);

    const vec3 normal = normalize(DecodeNormal(Texture2DLod(sampler_nearest, gbuffer_normals_texture, uv, 0.0)));
    const float depth = Texture2DLod(sampler_nearest, gbuffer_depth_texture, uv, 0.0).r;
    const vec3 position = ReconstructWorldSpacePositionFromDepth(projection_inverse, view_inverse, uv, depth).xyz;
    const vec4 material_data = Texture2DLod(sampler_nearest, gbuffer_material_texture, uv, 0.0);
    const float roughness = material_data.r;
    const float perceptual_roughness = sqrt(roughness);

    const vec3 V = normalize(camera.position.xyz - position);
    const vec3 R = normalize(reflect(-V, normal));

    const uint flags = gl_RayFlagsOpaqueEXT;
    const uint mask = 0xff;
    const float tmin = 0.1;
    const float tmax = 1000.0;

    uint ray_seed = InitRandomSeed(InitRandomSeed(gl_LaunchIDEXT.x * 2, gl_LaunchIDEXT.x * 2 + 1), scene.frame_counter % 256);

    vec4 color = vec4(0.0);

    const vec4 target = projection_inverse * vec4(uv * 2.0 - 1.0, 1.0, 1.0);
    const vec4 albedo = Texture2DLod(sampler_nearest, gbuffer_albedo_texture, uv, 0.0);

    vec4 radiance = vec4(0.0, 0.0, 0.0, 1.0);

    for (uint sample_index = 0; sample_index < NUM_SAMPLES; sample_index++) {
        vec2 rnd = vec2(RandomFloat(ray_seed), RandomFloat(ray_seed));

        vec3 tangent;
        vec3 bitangent;
        ComputeOrthonormalBasis(normal, tangent, bitangent);

        vec3 H = ImportanceSampleGGX(rnd, normal, roughness);
        H = tangent * H.x + bitangent * H.y + normal * H.z;

        vec3 direction = reflect(-V, H);
        // normalize(RandomInHemisphere(
        //     vec3(RandomFloat(ray_seed), RandomFloat(ray_seed), RandomFloat(ray_seed)),
        //     normal.xyz
        // ));
        vec3 origin = position + normal * RAY_OFFSET;

        // vec2 blue_noise_sample = vec2(
        //     SampleBlueNoise(storage_coord.x, storage_coord.y, 0, 0),
        //     SampleBlueNoise(storage_coord.x, storage_coord.y, 0, 1)
        // );

        // vec2 blue_noise_scaled = blue_noise_sample + float((scene.frame_counter) % 256) * 1.618;
        // const vec2 rnd = fmod(blue_noise_scaled, vec2(1.0));


        payload.throughput = albedo;
        payload.emissive = vec4(0.0);
        payload.beta = vec4(1.0);

        for (int bounce_index = 0; bounce_index < NUM_BOUNCES; bounce_index++) {
            vec4 throughput = payload.throughput;

            traceRayEXT(tlas, flags, mask, 0, 0, 0, origin, tmin, direction, tmax, 0);

            if (payload.distance < 0.0) {
                // hit the sky, sample the environment map
                if (current_env_probe.texture_index != ~0u) {
                    uint probe_texture_index = max(0, min(current_env_probe.texture_index, HYP_MAX_BOUND_REFLECTION_PROBES - 1));

                    vec4 emissive = TextureCube(sampler_linear, env_probe_textures[probe_texture_index], direction);

                    for (uint light_index = 0; light_index < rt_radiance_uniforms.num_bound_lights; light_index++) {
                        const Light light = HYP_GET_LIGHT(light_index);

                        if (light.type != 0) {
                            continue;
                        }

                        const float NdotL = max(dot(direction, light.position_intensity.xyz), 0.0);

                        emissive += UINT_TO_VEC4(light.color_encoded) * (light.position_intensity.w * NdotL);
                    }

                    radiance += emissive * throughput;
                }

                break;
            }

            radiance += payload.emissive * throughput;

            throughput = payload.throughput;
            
            // As the throughput is multiplied by the albedo, the probability of the ray getting discarded is higher
            float p = max(throughput.r, max(throughput.g, max(throughput.b, throughput.a)));

            if (RandomFloat(ray_seed) > p) {
                break;
            }

            payload.throughput /= max(p, 0.0001);
        
            ComputeOrthonormalBasis(payload.normal, tangent, bitangent);

            H = ImportanceSampleGGX(rnd, payload.normal, payload.roughness);
            H = tangent * H.x + bitangent * H.y + payload.normal * H.z;
                
            direction = reflect(direction, H);

            vec3 hit_position = origin + direction * payload.distance;
            origin = hit_position + payload.normal * RAY_OFFSET;
        }
    }

    color = radiance / float(NUM_SAMPLES);
    color.rgb = pow(color.rgb, vec3(1.0 / 2.2));
    
    // float max_component = max(color.r, max(color.g, color.b));

    // if (max_component < 0.0001) {
    //     // Discard the pixel if the color is too dark so it can accumulate more samples
    //     return;
    // }

    imageStore(image, storage_coord, color);
}
