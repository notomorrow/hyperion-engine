#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

#define HYP_NO_CUBEMAP

#include "../../include/defines.inc"
#include "../../include/noise.inc"
#include "../../include/packing.inc"
#include "../../include/tonemap.inc"

layout(set = 0, binding = 0) uniform accelerationStructureEXT tlas;
// radiance image
layout(set = 0, binding = 1, rgba16f) uniform image2D image;

layout(set = 0, binding = 6) uniform texture2D gbuffer_normals_texture;
layout(set = 0, binding = 7) uniform texture2D gbuffer_material_texture;
layout(set = 0, binding = 8) uniform texture2D gbuffer_depth_texture;
layout(set = 0, binding = 9) uniform texture2D gbuffer_albedo_texture;

layout(set = 0, binding = 10) uniform sampler sampler_nearest;
#define HYP_SAMPLER_NEAREST sampler_nearest

layout(set = 0, binding = 11) uniform sampler sampler_linear;
#define HYP_SAMPLER_LINEAR sampler_linear

#define HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

#include "../../include/scene.inc"
#include "../../include/shared.inc"
#include "../../include/packing.inc"
#include "../../include/noise.inc"
#include "../../include/brdf.inc"

/// Blue noise

layout(std140, set = 0, binding = 12) readonly buffer BlueNoiseBuffer {
	ivec4 sobol_256spp_256d[256 * 256 / 4];
	ivec4 scrambling_tile[128 * 128 * 8 / 4];
	ivec4 ranking_tile[128 * 128 * 8 / 4];
};

#include "../../include/BlueNoise.glsl"

#undef HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS
#undef HYP_NO_CUBEMAP

layout(std140, set = 1, binding = 0, row_major) readonly buffer SceneShaderData
{
    Scene scene;
};

layout(std140, set = 1, binding = 4, row_major) uniform CameraShaderData
{
    Camera camera;
};

layout(std430, set = 0, binding = 5) readonly buffer LightShaderData
{
    Light lights[];
};

#define PATHTRACER
#include "../../include/rt/RTRadiance.inc"
#include "../../include/rt/payload.inc"

layout(std140, set = 0, binding = 13, row_major) uniform RTRadianceUniformBuffer
{
    RTRadianceUniforms rt_radiance_uniforms;
};

layout(location = 0) rayPayloadEXT RayPayload payload;

#define RAY_OFFSET 0.01
#define NUM_SAMPLES 8
#define NUM_BOUNCES 8

void main() 
{
    const ivec2 resolution = imageSize(image);

    const ivec2 storage_coord = clamp(ivec2(gl_LaunchIDEXT.xy), ivec2(0), resolution - ivec2(1));

    const int pixel_index = storage_coord.y * resolution.x + storage_coord.x;

    //if (pixel_index % 2 == 0) {
    //    return;
    //}

    const vec2 uv = (vec2(storage_coord) + 0.5) / vec2(resolution);

    const mat4 view_inverse = inverse(camera.view);
    const mat4 projection_inverse = inverse(camera.projection);

    const vec3 normal = normalize(DecodeNormal(Texture2DLod(sampler_nearest, gbuffer_normals_texture, uv, 0.0)));
    const float depth = Texture2DLod(sampler_nearest, gbuffer_depth_texture, uv, 0.0).r;
    const vec3 position = ReconstructWorldSpacePositionFromDepth(projection_inverse, view_inverse, uv, depth).xyz;
    const vec4 material_data = Texture2DLod(sampler_nearest, gbuffer_material_texture, uv, 0.0);
    const float roughness = material_data.r;
    const float perceptual_roughness = sqrt(roughness);

    const vec3 V = normalize(camera.position.xyz - position);
    const vec3 R = normalize(reflect(-V, normal));

    const uint flags = gl_RayFlagsOpaqueEXT;
    const uint mask = 0xff;
    const float tmin = 0.1;
    const float tmax = 1000.0;

    uint ray_seed = InitRandomSeed(InitRandomSeed(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), scene.frame_counter % 256);

    vec3 color = vec3(0.0);

    const vec4 target = projection_inverse * vec4(uv * 2.0 - 1.0, 1.0, 1.0);
    const vec4 albedo = Texture2DLod(sampler_nearest, gbuffer_albedo_texture, uv, 0.0);

    vec4 radiance = vec4(0.0, 0.0, 0.0, 1.0);

    for (uint sample_index = 0; sample_index < NUM_SAMPLES; sample_index++) {
        vec2 rnd = vec2(RandomFloat(ray_seed), RandomFloat(ray_seed));

        vec3 tangent;
        vec3 bitangent;
        ComputeOrthonormalBasis(normal, tangent, bitangent);

        vec3 H = ImportanceSampleGGX(rnd, normal, roughness);
        H = tangent * H.x + bitangent * H.y + normal * H.z;

        vec3 direction = reflect(-V, H);
        vec3 origin = position + normal * RAY_OFFSET;

        // vec2 blue_noise_sample = vec2(
        //     SampleBlueNoise(storage_coord.x, storage_coord.y, 0, 0),
        //     SampleBlueNoise(storage_coord.x, storage_coord.y, 0, 1)
        // );

        // vec2 blue_noise_scaled = blue_noise_sample + float((scene.frame_counter) % 256) * 1.618;
        // const vec2 rnd = fmod(blue_noise_scaled, vec2(1.0));


        payload.throughput = albedo.rgb;
        payload.emissive = vec3(0.0);

        for (int bounce_index = 0; bounce_index < NUM_BOUNCES; bounce_index++) {
            vec3 throughput = payload.throughput;

            payload.dir = direction;
            traceRayEXT(tlas, flags, mask, 0, 0, 0, origin, tmin, direction, tmax, 0);

            radiance.rgb += payload.emissive * throughput;

            throughput = payload.throughput;
            
            // As the throughput is multiplied by the albedo, the probability of the ray getting discarded is higher
            float p = max(throughput.r, max(throughput.g, throughput.b));

            if (RandomFloat(ray_seed) > p) {
                break;
            }

            payload.throughput /= max(p, 0.0001);
        
            ComputeOrthonormalBasis(payload.normal, tangent, bitangent);

            H = ImportanceSampleGGX(rnd, payload.normal, payload.roughness);
            H = tangent * H.x + bitangent * H.y + payload.normal * H.z;
                
            direction = reflect(direction, H);

            vec3 hit_position = origin + direction * payload.distance;
            origin = hit_position + payload.normal * RAY_OFFSET;
        }
    }

    color = radiance.rgb / float(NUM_SAMPLES * NUM_BOUNCES);
    
    // float max_component = max(color.r, max(color.g, color.b));

    // if (max_component < 0.0001) {
    //     // Discard the pixel if the color is too dark so it can accumulate more samples
    //     return;
    // }

    imageStore(image, storage_coord, vec4(color, 1.0));
}
