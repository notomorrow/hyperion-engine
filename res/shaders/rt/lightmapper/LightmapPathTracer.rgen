#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

#include "../../include/defines.inc"
#include "../../include/noise.inc"
#include "../../include/packing.inc"

HYP_DESCRIPTOR_SAMPLER(Global, SamplerNearest) uniform sampler sampler_nearest;
HYP_DESCRIPTOR_SAMPLER(Global, SamplerLinear) uniform sampler sampler_linear;

#define texture_sampler sampler_linear
#define HYP_SAMPLER_NEAREST sampler_nearest
#define HYP_SAMPLER_LINEAR sampler_linear

HYP_DESCRIPTOR_ACCELERATION_STRUCTURE(RTRadianceDescriptorSet, TLAS) uniform accelerationStructureEXT tlas;

#define HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

#include "../../include/scene.inc"
#include "../../include/shared.inc"
#include "../../include/packing.inc"
#include "../../include/noise.inc"
#include "../../include/brdf.inc"
#include "../../include/env_probe.inc"

/// Blue noise
HYP_DESCRIPTOR_SSBO(Global, BlueNoiseBuffer, size = 1310720) readonly buffer BlueNoiseBuffer
{
	ivec4 sobol_256spp_256d[256 * 256 / 4];
	ivec4 scrambling_tile[128 * 128 * 8 / 4];
	ivec4 ranking_tile[128 * 128 * 8 / 4];
};

#include "../../include/BlueNoise.glsl"

#undef HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

HYP_DESCRIPTOR_SSBO(RTRadianceDescriptorSet, LightsBuffer) readonly buffer LightsBuffer
{
    Light lights[];
};

HYP_DESCRIPTOR_CBUFF(Global, WorldsBuffer) uniform WorldsBuffer
{
    WorldShaderData world_shader_data;
};

HYP_DESCRIPTOR_SRV(Global, EnvProbeTextures, count = 16) uniform texture2D env_probe_textures[16];
HYP_DESCRIPTOR_SSBO(Global, EnvProbesBuffer) readonly buffer EnvProbesBuffer { EnvProbe env_probes[]; };
HYP_DESCRIPTOR_CBUFF_DYNAMIC(Global, EnvGridsBuffer) uniform EnvGridsBuffer { EnvGrid env_grid; };
HYP_DESCRIPTOR_SSBO_DYNAMIC(Global, CurrentEnvProbe) readonly buffer CurrentEnvProbe { EnvProbe current_env_probe; };

#include "../../include/Octahedron.glsl"

#define PATHTRACER
#define LIGHTMAPPER
#include "../../include/rt/RTRadiance.inc"
#include "../../include/rt/payload.inc"

layout(location = 0) rayPayloadEXT RayPayload payload;

HYP_DESCRIPTOR_SSBO(RTRadianceDescriptorSet, HitsBuffer, standard = scalar) buffer HitsBuffer
{
    vec4 hits[];
};

struct LightmapRay
{
    vec4 origin;
    vec4 direction;
};

HYP_DESCRIPTOR_SSBO(RTRadianceDescriptorSet, RaysBuffer, standard = scalar) readonly buffer RaysBuffer
{
    vec4 ray_data[];
};

HYP_DESCRIPTOR_CBUFF(RTRadianceDescriptorSet, RTRadianceUniforms) uniform RTRadianceUniformBuffer
{
    RTRadianceUniforms  rt_radiance_uniforms;
};

#ifdef MODE_IRRADIANCE

#define RAY_OFFSET 0.001
#define NUM_BOUNCES 4
#define NUM_SAMPLES 8
#else
#define RAY_OFFSET 0.001
#define NUM_BOUNCES 1
#define NUM_SAMPLES 1
#endif

// This function is used to debug the albedo color by tracing a ray onto the surface
// and returning the albedo color at that point.
vec3 DebugTest_Albedo(in vec3 position, in vec3 normal)
{
    // Save payload state
    vec4 saved_throughput = payload.throughput;
    vec4 saved_emissive = payload.emissive;
    float saved_distance = payload.distance;
    vec3 saved_normal = payload.normal;
    vec3 saved_bary = payload.barycentric_coords;
    uint saved_tri = payload.triangle_index;

    // Set up ray to hit the surface from a small offset
    vec3 origin = position + normal * 0.001;
    vec3 direction = -normal;

    // Reset payload for this trace
    payload.distance = -1.0;
    payload.throughput = vec4(0.0);
    payload.emissive = vec4(0.0);
    payload.triangle_index = ~0u;
    payload.normal = vec3(0.0);

    traceRayEXT(tlas, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, 0.0, direction, 1.0, 0);

    vec3 albedo = vec3(0.0);
    if (payload.distance >= 0.0) {
        albedo = payload.throughput.rgb;
    }

    // Restore payload
    payload.throughput = saved_throughput;
    payload.emissive = saved_emissive;
    payload.distance = saved_distance;
    payload.normal = saved_normal;
    payload.barycentric_coords = saved_bary;
    payload.triangle_index = saved_tri;

    return albedo;
}

float CheckInShadow(in vec3 position, in vec3 lightDir)
{
    // Save payload state
    vec4 saved_throughput = payload.throughput;
    vec4 saved_emissive = payload.emissive;
    float saved_distance = payload.distance;
    vec3 saved_normal = payload.normal;
    vec3 saved_bary = payload.barycentric_coords;
    uint saved_tri = payload.triangle_index;

    // Set up ray to hit the surface from a small offset
    vec3 origin = position + lightDir * 0.001;
    vec3 direction = lightDir;

    // Reset payload for this trace
    payload.distance = -1.0;
    payload.throughput = vec4(0.0);
    payload.emissive = vec4(0.0);
    payload.triangle_index = ~0u;
    payload.normal = vec3(0.0);

    traceRayEXT(tlas, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, 0.001, direction, 1000.0, 0);

    float inShadow = (payload.distance < 0.0) ? 1.0 : 0.0;

    // Restore payload
    payload.throughput = saved_throughput;
    payload.emissive = saved_emissive;
    payload.distance = saved_distance;
    payload.normal = saved_normal;
    payload.barycentric_coords = saved_bary;
    payload.triangle_index = saved_tri;

    return inShadow;
}

vec3 SampleCosineDir(in vec2 xi, in vec3 N)
{
    vec3 dir = SampleCosineWeightedHemisphere(xi);

    vec3 T1, T2;
    ComputeOrthonormalBasis(N, T1, T2);

    return normalize(T1 * dir.x + T2 * dir.y + N * dir.z);
}

void main()
{
    const uint ray_index = gl_LaunchIDEXT.x;

    LightmapRay ray;
    ray.origin = vec4(ray_data[ray_index * 2].xyz, 1.0);
    ray.direction = vec4(ray_data[ray_index * 2 + 1].xyz, 0.0);

    const uint flags = gl_RayFlagsOpaqueEXT;
    const uint mask = 0xff;
    const float tmin = 0.001;
    const float tmax = 1000.0;

    const vec3 N0 = normalize(ray.direction.xyz);

    vec3 tangent;
    vec3 bitangent;

    vec4 accumRadiance = vec4(0.0);

    uint ray_seed = InitRandomSeed(((rt_radiance_uniforms.ray_offset + ray_index) * 2), ((rt_radiance_uniforms.ray_offset + ray_index) * 2) + 1);

    for (uint sample_index = 0; sample_index < NUM_SAMPLES; sample_index++) {
        vec3 direction;
        vec2 rnd = vec2(RandomFloat(ray_seed), RandomFloat(ray_seed));

#ifdef MODE_IRRADIANCE
        direction = SampleCosineDir(rnd, N0);
#else
        direction = N0;
#endif

        direction = normalize(direction);

        vec3 origin = ray.origin.xyz + N0 * RAY_OFFSET;

        vec3 radiance = vec3(0.0);
        vec3 beta = vec3(1.0);

        for (int bounceIndex = 0; bounceIndex < NUM_BOUNCES; ++bounceIndex) {
            // perform scene trace using global payload
            payload.distance = -1.0;
            payload.throughput = vec4(1.0);
            payload.emissive = vec4(0.0);
            payload.triangle_index = ~0u;
            payload.normal = vec3(0.0);

            traceRayEXT(tlas, flags, mask, 0, 0, 0, origin, tmin, direction, tmax, 0);

            if (payload.distance < 0.0) {
                // miss -> sample environment probe if present
                if (current_env_probe.texture_index != ~0u) {
                    uint probe_texture_index = max(0, min(current_env_probe.texture_index, HYP_MAX_BOUND_REFLECTION_PROBES - 1));
                    vec3 env = Texture2D(sampler_linear, env_probe_textures[probe_texture_index], EncodeOctahedralCoord(normalize(direction)) * 0.5 + 0.5).rgb;
                    radiance += beta * env;
                }
                break;
            }

            vec3 albedo = clamp(payload.throughput.rgb, vec3(0.0), vec3(1.0));
            float metalness = payload.throughput.a;

            vec3 hitPos = origin + direction * payload.distance;
            vec3 N = normalize(payload.normal);

            // emissive
            if (length(payload.emissive.rgb) > 0.0) {
                radiance += beta * payload.emissive.rgb;
            }

            beta *= clamp(payload.throughput.rgb, vec3(0.0), vec3(1.0));

            for (uint light_index = 0; light_index < rt_radiance_uniforms.num_bound_lights; light_index++) {
                const Light light = HYP_GET_LIGHT(light_index);
                vec3 light_color = UINT_TO_VEC4(light.color_encoded).rgb;

                if (light.type == HYP_LIGHT_TYPE_DIRECTIONAL) {
                    vec3 light_direction = normalize(light.position_intensity.xyz);
                    vec3 L = light_direction;

                    // shadow check
                    float shadow = 1.0;
                    if ((light.flags & LF_SHADOW) != 0) {
                        shadow = 1.0 - CheckInShadow(hitPos, L);
                    }

                    float NdotL = max(dot(N, L), 0.0);
                    radiance += beta * NdotL * shadow * light_color * HYP_FMATH_ONE_OVER_PI;
                } else if (light.type == HYP_LIGHT_TYPE_POINT) {
                    vec3 L = normalize(light.position_intensity.xyz - hitPos);
                    float d = length(light.position_intensity.xyz - hitPos);
                    float attenuation = 1.0 / (d * d);

                    float NdotL = max(dot(N, L), 0.0);
                    radiance += beta * NdotL * light_color * HYP_FMATH_ONE_OVER_PI * attenuation;
                } else {
                    /// ... TODO
                }
            }

            if (bounceIndex >= 2) {
                float p = clamp(max(max(beta.r, beta.g), beta.b), 0.05, 0.99);
                if (RandomFloat(ray_seed) > p) {
                    break;
                }
                beta /= p;
            }

            rnd = vec2(RandomFloat(ray_seed), RandomFloat(ray_seed));

            direction = normalize(SampleCosineDir(rnd, N));
            origin = hitPos + N * RAY_OFFSET;
        } // end bounces

        accumRadiance.rgb += radiance;
    } // end samples

    vec3 finalColor = accumRadiance.rgb / float(NUM_SAMPLES);

    // // test
    // float inShadow = DebugTest_InShadow(ray.origin.xyz, HYP_GET_LIGHT(0).position_intensity.xyz);

    hits[ray_index] = vec4(finalColor, 1.0);
}
