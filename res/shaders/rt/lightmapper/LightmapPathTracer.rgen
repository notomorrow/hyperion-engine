#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_scalar_block_layout : require

#include "../../include/defines.inc"
#include "../../include/noise.inc"
#include "../../include/packing.inc"

HYP_DESCRIPTOR_SAMPLER(Global, SamplerNearest) uniform sampler sampler_nearest;
HYP_DESCRIPTOR_SAMPLER(Global, SamplerLinear) uniform sampler sampler_linear;

#define texture_sampler sampler_linear
#define HYP_SAMPLER_NEAREST sampler_nearest
#define HYP_SAMPLER_LINEAR sampler_linear

HYP_DESCRIPTOR_ACCELERATION_STRUCTURE(RTRadianceDescriptorSet, TLAS) uniform accelerationStructureEXT tlas;

#define HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

#include "../../include/scene.inc"
#include "../../include/shared.inc"
#include "../../include/packing.inc"
#include "../../include/noise.inc"
#include "../../include/brdf.inc"
#include "../../include/env_probe.inc"

/// Blue noise
HYP_DESCRIPTOR_SSBO(Global, BlueNoiseBuffer, size = 1310720) readonly buffer BlueNoiseBuffer
{
	ivec4 sobol_256spp_256d[256 * 256 / 4];
	ivec4 scrambling_tile[128 * 128 * 8 / 4];
	ivec4 ranking_tile[128 * 128 * 8 / 4];
};

#include "../../include/BlueNoise.glsl"

#undef HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

HYP_DESCRIPTOR_SSBO(RTRadianceDescriptorSet, LightsBuffer) readonly buffer LightsBuffer
{
    Light lights[];
};

HYP_DESCRIPTOR_CBUFF(Global, WorldsBuffer) uniform WorldsBuffer
{
    WorldShaderData world_shader_data;
};

HYP_DESCRIPTOR_SRV(Global, EnvProbeTextures, count = 16) uniform texture2D env_probe_textures[16];
HYP_DESCRIPTOR_SSBO(Global, EnvProbesBuffer) readonly buffer EnvProbesBuffer { EnvProbe env_probes[]; };
HYP_DESCRIPTOR_CBUFF_DYNAMIC(Global, EnvGridsBuffer) uniform EnvGridsBuffer { EnvGrid env_grid; };
HYP_DESCRIPTOR_SSBO_DYNAMIC(Global, CurrentEnvProbe) readonly buffer CurrentEnvProbe { EnvProbe current_env_probe; };

#include "../../include/Octahedron.glsl"

#define PATHTRACER
#define LIGHTMAPPER
#include "../../include/rt/RTRadiance.inc"
#include "../../include/rt/payload.inc"

layout(location = 0) rayPayloadEXT RayPayload payload;

HYP_DESCRIPTOR_SSBO(RTRadianceDescriptorSet, HitsBuffer, standard = scalar) buffer HitsBuffer
{
    vec4 hits[];
};

struct LightmapRay
{
    vec3 origin;
    vec3 direction;
};

HYP_DESCRIPTOR_SSBO(RTRadianceDescriptorSet, RaysBuffer, standard = scalar) readonly buffer RaysBuffer
{
    vec4 ray_data[];
};

HYP_DESCRIPTOR_CBUFF(RTRadianceDescriptorSet, RTRadianceUniforms) uniform RTRadianceUniformBuffer
{
    RTRadianceUniforms  rt_radiance_uniforms;
};

#ifdef MODE_IRRADIANCE

#define RAY_OFFSET 0.005
#define NUM_BOUNCES 8
#define NUM_SAMPLES 1
#else
#define RAY_OFFSET 0.01
#define NUM_BOUNCES 1
#define NUM_SAMPLES 1
#endif

// This function is used to debug the albedo color by tracing a ray onto the surface
// and returning the albedo color at that point.
vec3 DebugTest_Albedo(in vec3 position, in vec3 normal)
{
    // Save payload state
    vec4 saved_throughput = payload.throughput;
    vec4 saved_emissive = payload.emissive;
    float saved_distance = payload.distance;
    vec3 saved_normal = payload.normal;
    vec3 saved_bary = payload.barycentric_coords;

    // Set up ray to hit the surface from a small offset
    vec3 origin = position + normal * 0.001;
    vec3 direction = -normal;

    // Reset payload for this trace
    payload.distance = -1.0;
    payload.throughput = vec4(0.0);
    payload.emissive = vec4(0.0);
    payload.normal = vec3(0.0);

    traceRayEXT(tlas, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, 0.0, direction, 1.0, 0);

    vec3 albedo = vec3(0.0);
    if (payload.distance >= 0.0) {
        albedo = payload.throughput.rgb;
    }

    // Restore payload
    payload.throughput = saved_throughput;
    payload.emissive = saved_emissive;
    payload.distance = saved_distance;
    payload.normal = saved_normal;
    payload.barycentric_coords = saved_bary;

    return albedo;
}

float CheckInShadow(vec3 position, vec3 normal, vec3 lightDir)
{
    vec3 origin = position + normal * 0.01;
    vec3 direction = lightDir;

    rayQueryEXT rq;
    rayQueryInitializeEXT(rq, tlas,
        gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT,
        0xff, origin, 0.0001, direction, 1000.0);

    rayQueryProceedEXT(rq);

    return float(rayQueryGetIntersectionTypeEXT(rq, true) != gl_RayQueryCommittedIntersectionNoneEXT);
}

vec3 radiance = vec3(0.0);
vec3 beta = vec3(1.0);

void main()
{
    const uint ray_index = gl_LaunchIDEXT.x;

    LightmapRay ray;
    ray.origin = ray_data[ray_index * 2].xyz;
    ray.direction = ray_data[ray_index * 2 + 1].xyz;

    const uint flags = gl_RayFlagsOpaqueEXT;
    const uint mask = 0xff;
    const float tmin = 0.01;
    const float tmax = 1000.0;

    const vec3 N0 = normalize(ray.direction);

    vec3 tangent;
    vec3 bitangent;

    vec4 accumRadiance = vec4(0.0);

    uint ray_seed = InitRandomSeed(((rt_radiance_uniforms.ray_offset + ray_index) * 2), ((rt_radiance_uniforms.ray_offset + ray_index) * 2) + 1);

#ifdef MODE_IRRADIANCE
    for (uint sample_index = 0; sample_index < NUM_SAMPLES; sample_index++) {
        vec2 rnd = vec2(RandomFloat(ray_seed), RandomFloat(ray_seed));

        vec3 direction = SampleCosineDir(rnd, N0);
        direction = normalize(direction);

        vec3 origin = ray.origin + N0 * RAY_OFFSET;

        vec3 radiance = vec3(0.0);
        vec3 beta = vec3(1.0);

        for (int bounceIndex = 0; bounceIndex < NUM_BOUNCES; ++bounceIndex) {
            // perform scene trace using global payload
            payload.distance = -1.0;
            payload.throughput = vec4(1.0);
            payload.emissive = vec4(0.0);
            payload.normal = vec3(0.0);

            traceRayEXT(tlas, flags, mask, 0, 0, 0, origin, tmin, direction, tmax, 0);

            if (payload.distance < 0.0) {
                // miss -> sample environment probe if present
                if (current_env_probe.texture_index != ~0u) {
                    uint probe_texture_index = max(0, min(current_env_probe.texture_index, HYP_MAX_BOUND_REFLECTION_PROBES - 1));
                    vec3 env = Texture2D(sampler_linear, env_probe_textures[probe_texture_index], EncodeOctahedralCoord(normalize(direction)) * 0.5 + 0.5).rgb;
                    radiance += beta * env;
                }
                break;
            }

            vec3 albedo = clamp(payload.throughput.rgb, vec3(0.0), vec3(1.0));
            float metalness = payload.throughput.a;

            vec3 hitPos = origin + direction * payload.distance;
            vec3 N = normalize(payload.normal);

            // emissive
            if (length(payload.emissive.rgb) > 0.0) {
                radiance += beta * payload.emissive.rgb;
            }

            beta *= albedo * (1.0 - metalness) * HYP_FMATH_ONE_OVER_PI;

            for (uint light_index = 0; light_index < rt_radiance_uniforms.num_bound_lights; light_index++) {
                const Light light = HYP_GET_LIGHT(light_index);
                vec3 light_color = UINT_TO_VEC4(light.color_encoded).rgb * light.position_intensity.w;

                if (light.type == HYP_LIGHT_TYPE_DIRECTIONAL) {
                    vec3 light_direction = normalize(light.position_intensity.xyz);
                    vec3 L = light_direction;

                    // shadow check
                    float shadow = 1.0 - CheckInShadow(hitPos, N, L);

                    float NdotL = max(dot(N, L), 0.0);
                    radiance += beta * NdotL * shadow * light_color;
                } else if (light.type == HYP_LIGHT_TYPE_POINT) {
                    vec3 L = normalize(light.position_intensity.xyz - hitPos);
                    float d = length(light.position_intensity.xyz - hitPos);
                    float attenuation = 1.0 / (d * d);

                    float NdotL = max(dot(N, L), 0.0);
                    radiance += beta * NdotL * light_color * attenuation;
                } else {
                    /// ... TODO
                }
            }

            if (bounceIndex >= 3) {
                float p = clamp(max(max(beta.r, beta.g), beta.b), 0.05, 0.99);
                if (RandomFloat(ray_seed) > p) {
                    break;
                }
                beta /= vec3(p);
            }

            rnd = vec2(RandomFloat(ray_seed), RandomFloat(ray_seed));

            direction = normalize(SampleCosineDir(rnd, N));
            origin = hitPos + N * RAY_OFFSET;
        } // end bounces

        accumRadiance.rgb += radiance;
    } // end samples


    vec3 finalColor = accumRadiance.rgb / float(NUM_SAMPLES);
#elif defined(MODE_RADIANCE)
    // direct shading
    
    const vec3 N = N0;

    vec3 radiance = vec3(0.0);

    for (uint light_index = 0; light_index < rt_radiance_uniforms.num_bound_lights; light_index++) {
        const Light light = HYP_GET_LIGHT(light_index);
        vec3 light_color = UINT_TO_VEC4(light.color_encoded).rgb * light.position_intensity.w;

        if (light.type == HYP_LIGHT_TYPE_DIRECTIONAL) {
            vec3 light_direction = normalize(light.position_intensity.xyz);
            vec3 L = light_direction;

            // shadow check
            float shadow = 1.0 - CheckInShadow(ray.origin, N, L);

            float NdotL = max(dot(N, L), 0.0);
            radiance += light_color * NdotL * shadow;
        } else if (light.type == HYP_LIGHT_TYPE_POINT) {
            vec3 L = normalize(light.position_intensity.xyz - ray.origin);
            float d = length(light.position_intensity.xyz - ray.origin);
            float attenuation = 1.0 / (d * d);

            float NdotL = max(dot(N, L), 0.0);
            radiance += light_color * NdotL * attenuation;
        } else {
            /// ... TODO
        }
    }

    vec3 finalColor = radiance;
#else
    vec3 finalColor = vec3(0.0);
#endif

    hits[ray_index] = vec4(finalColor, 1.0);
}
