#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

#include "../../include/defines.inc"
#include "../../include/noise.inc"
#include "../../include/packing.inc"
#include "../../include/tonemap.inc"

HYP_DESCRIPTOR_SAMPLER(Global, SamplerNearest) uniform sampler sampler_nearest;
HYP_DESCRIPTOR_SAMPLER(Global, SamplerLinear) uniform sampler sampler_linear;

#define texture_sampler sampler_linear
#define HYP_SAMPLER_NEAREST sampler_nearest
#define HYP_SAMPLER_LINEAR sampler_linear

HYP_DESCRIPTOR_ACCELERATION_STRUCTURE(RTRadianceDescriptorSet, TLAS) uniform accelerationStructureEXT tlas;

#define HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

#include "../../include/scene.inc"
#include "../../include/shared.inc"
#include "../../include/packing.inc"
#include "../../include/noise.inc"
#include "../../include/brdf.inc"
#include "../../include/env_probe.inc"

/// Blue noise
HYP_DESCRIPTOR_SSBO(Global, BlueNoiseBuffer, size = 1310720) readonly buffer BlueNoiseBuffer
{
	ivec4 sobol_256spp_256d[256 * 256 / 4];
	ivec4 scrambling_tile[128 * 128 * 8 / 4];
	ivec4 ranking_tile[128 * 128 * 8 / 4];
};

#include "../../include/BlueNoise.glsl"

#undef HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

HYP_DESCRIPTOR_SSBO(RTRadianceDescriptorSet, LightsBuffer) readonly buffer LightsBuffer
{
    Light lights[];
};

HYP_DESCRIPTOR_SSBO_DYNAMIC(Scene, ScenesBuffer, size = 256) readonly buffer SceneBuffer
{
    Scene scene;
};

HYP_DESCRIPTOR_SRV(Scene, EnvProbeTextures, count = 16) uniform textureCube env_probe_textures[16];
HYP_DESCRIPTOR_SSBO(Scene, EnvProbesBuffer, size = 131072) readonly buffer EnvProbesBuffer { EnvProbe env_probes[HYP_MAX_ENV_PROBES]; };
HYP_DESCRIPTOR_CBUFF_DYNAMIC(Scene, EnvGridsBuffer, size = 4352) uniform EnvGridsBuffer { EnvGrid env_grid; };
HYP_DESCRIPTOR_SSBO(Scene, SHGridBuffer, size = 147456) readonly buffer SHGridBuffer { vec4 sh_grid_buffer[SH_GRID_BUFFER_SIZE]; };
HYP_DESCRIPTOR_SSBO_DYNAMIC(Scene, CurrentEnvProbe, size = 512) readonly buffer CurrentEnvProbe
{
    EnvProbe current_env_probe;
};

#define PATHTRACER
#define LIGHTMAPPER
#include "../../include/rt/RTRadiance.inc"
#include "../../include/rt/payload.inc"

layout(location = 0) rayPayloadEXT RayPayload payload;

struct LightmapHit
{
    vec4 color;
};

HYP_DESCRIPTOR_SSBO(RTRadianceDescriptorSet, HitsBuffer, size = 65536) buffer HitsBuffer
{
    LightmapHit hits[4096];
};

struct Ray
{
    vec4 origin;
    vec4 direction;
};

HYP_DESCRIPTOR_SSBO(RTRadianceDescriptorSet, RaysBuffer) readonly buffer RaysBuffer
{
    Ray rays[];
};

#define RAY_OFFSET 0.01
#define NUM_SAMPLES 8
#define NUM_BOUNCES 8

void main() 
{
    const uint ray_index = gl_LaunchIDEXT.x;
    const Ray ray = rays[ray_index];

    const uint flags = gl_RayFlagsOpaqueEXT;
    const uint mask = 0xff;
    const float tmin = 0.1;
    const float tmax = 1000.0;

    vec3 color = vec3(0.0);

    vec4 radiance = vec4(0.0, 0.0, 0.0, 1.0);

    uint ray_seed = InitRandomSeed(InitRandomSeed(gl_LaunchIDEXT.x * 2, gl_LaunchIDEXT.x * 2 + 1), scene.frame_counter % 256);

    for (uint sample_index = 0; sample_index < NUM_SAMPLES; sample_index++) {
        vec2 rnd = vec2(RandomFloat(ray_seed), RandomFloat(ray_seed));

        vec3 H;

        // vec3 tangent;
        // vec3 bitangent;
        // ComputeOrthonormalBasis(normal, tangent, bitangent);

        // vec3 H = ImportanceSampleGGX(rnd, normal, roughness);
        // H = tangent * H.x + bitangent * H.y + normal * H.z;

        // vec3 direction = reflect(-V, H);
        // vec3 origin = position + normal * RAY_OFFSET;

        vec3 direction = normalize(RandomInHemisphere(
            vec3(RandomFloat(ray_seed), RandomFloat(ray_seed), RandomFloat(ray_seed)),
            ray.direction.xyz
        ));
        vec3 origin = ray.origin.xyz;

        payload.throughput = vec3(1.0);
        payload.emissive = vec3(0.0);
        payload.triangle_index = ~0u;
        payload.entity_index = ~0u;

        for (int bounce_index = 0; bounce_index < NUM_BOUNCES; bounce_index++) {
            vec3 throughput = payload.throughput;

            payload.dir = direction;
            traceRayEXT(tlas, flags, mask, 0, 0, 0, origin, tmin, direction, tmax, 0);

            if (payload.distance < 0.0) {
                // hit the sky, sample the environment map
                if (current_env_probe.texture_index != ~0u) {
                    uint probe_texture_index = max(0, min(current_env_probe.texture_index, HYP_MAX_BOUND_REFLECTION_PROBES - 1));

                    radiance.rgb += TextureCube(sampler_linear, env_probe_textures[probe_texture_index], direction).rgb * throughput;
                }

                break;
            }

            radiance.rgb += payload.emissive * throughput;

            throughput = payload.throughput;
            
            // As the throughput is multiplied by the albedo, the probability of the ray getting discarded is higher
            float p = max(throughput.r, max(throughput.g, throughput.b));

            if (RandomFloat(ray_seed) > p) {
                break;
            }

            payload.throughput /= max(p, 0.0001);
        
            vec3 tangent;
            vec3 bitangent;
            ComputeOrthonormalBasis(payload.normal, tangent, bitangent);

            H = ImportanceSampleGGX(rnd, payload.normal, payload.roughness);
            H = tangent * H.x + bitangent * H.y + payload.normal * H.z;
                
            direction = reflect(direction, H);

            vec3 hit_position = origin + direction * payload.distance;
            origin = hit_position + payload.normal * RAY_OFFSET;
        }
    }

    color = radiance.rgb / float(NUM_SAMPLES);
    
    hits[ray_index].color = vec4(color, 1.0);
}
