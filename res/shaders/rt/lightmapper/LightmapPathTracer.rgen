#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

#include "../../include/defines.inc"
#include "../../include/noise.inc"
#include "../../include/packing.inc"

HYP_DESCRIPTOR_SAMPLER(Global, SamplerNearest) uniform sampler sampler_nearest;
HYP_DESCRIPTOR_SAMPLER(Global, SamplerLinear) uniform sampler sampler_linear;

#define texture_sampler sampler_linear
#define HYP_SAMPLER_NEAREST sampler_nearest
#define HYP_SAMPLER_LINEAR sampler_linear

HYP_DESCRIPTOR_ACCELERATION_STRUCTURE(RTRadianceDescriptorSet, TLAS) uniform accelerationStructureEXT tlas;

#define HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

#include "../../include/scene.inc"
#include "../../include/shared.inc"
#include "../../include/packing.inc"
#include "../../include/noise.inc"
#include "../../include/brdf.inc"
#include "../../include/env_probe.inc"

/// Blue noise
HYP_DESCRIPTOR_SSBO(Global, BlueNoiseBuffer, size = 1310720) readonly buffer BlueNoiseBuffer
{
	ivec4 sobol_256spp_256d[256 * 256 / 4];
	ivec4 scrambling_tile[128 * 128 * 8 / 4];
	ivec4 ranking_tile[128 * 128 * 8 / 4];
};

#include "../../include/BlueNoise.glsl"

#undef HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

HYP_DESCRIPTOR_SSBO(RTRadianceDescriptorSet, LightsBuffer) readonly buffer LightsBuffer
{
    Light lights[];
};

HYP_DESCRIPTOR_CBUFF(Global, WorldsBuffer) uniform WorldsBuffer
{
    WorldShaderData world_shader_data;
};

HYP_DESCRIPTOR_SRV(Global, EnvProbeTextures, count = 16) uniform texture2D env_probe_textures[16];
HYP_DESCRIPTOR_SSBO(Global, EnvProbesBuffer) readonly buffer EnvProbesBuffer { EnvProbe env_probes[]; };
HYP_DESCRIPTOR_CBUFF_DYNAMIC(Global, EnvGridsBuffer) uniform EnvGridsBuffer { EnvGrid env_grid; };
HYP_DESCRIPTOR_SSBO_DYNAMIC(Global, CurrentEnvProbe) readonly buffer CurrentEnvProbe { EnvProbe current_env_probe; };

#include "../../include/Octahedron.glsl"

#define PATHTRACER
#define LIGHTMAPPER
#include "../../include/rt/RTRadiance.inc"
#include "../../include/rt/payload.inc"

layout(location = 0) rayPayloadEXT RayPayload payload;

HYP_DESCRIPTOR_SSBO(RTRadianceDescriptorSet, HitsBuffer, standard = scalar) buffer HitsBuffer
{
    vec4 hits[];
};

struct LightmapRay
{
    vec4 origin;
    vec4 direction;
};

HYP_DESCRIPTOR_SSBO(RTRadianceDescriptorSet, RaysBuffer, standard = scalar) readonly buffer RaysBuffer
{
    vec4 ray_data[];
};

HYP_DESCRIPTOR_CBUFF(RTRadianceDescriptorSet, RTRadianceUniforms) uniform RTRadianceUniformBuffer
{
    RTRadianceUniforms  rt_radiance_uniforms;
};

#ifdef MODE_IRRADIANCE

#define RAY_OFFSET 0.0001
#define NUM_BOUNCES 4
#define NUM_SAMPLES 4
#else
#define RAY_OFFSET 0.0001
#define NUM_BOUNCES 1
#define NUM_SAMPLES 1
#endif

const float INV_PI = 1.0 / 3.14159265358979323846;

vec3 EvaluateDiffuseLighting(in vec3 albedo, float metalness, in vec3 position, in vec3 normal)
{
    vec3 outLi = vec3(0.0);

    for (uint light_index = 0; light_index < rt_radiance_uniforms.num_bound_lights; light_index++) {
        const Light light = HYP_GET_LIGHT(light_index);

        if (light.type == HYP_LIGHT_TYPE_DIRECTIONAL) {
            vec3 wi = -normalize(light.position_intensity.xyz);
            float NoL = max(0.0, dot(normal, wi));
            if (NoL <= 0.0) {
                continue;
            }

            vec3 f = albedo * INV_PI * (1.0 - metalness);
            vec3 Li = UINT_TO_VEC4(light.color_encoded).rgb * light.position_intensity.w;
            outLi += f * Li * NoL;
        } else if (light.type == HYP_LIGHT_TYPE_POINT) {
            vec2 radiusFalloff = unpackHalf2x16(light.radius_falloff);
            float radius = radiusFalloff.x;

            vec3 lightPos = light.position_intensity.xyz;
            float dist = length(lightPos - position);
            float distSqr = dist * dist;

            float invRadius = 1.0 / radius;
            float factor = distSqr * (invRadius * invRadius);
            float smoothFactor = max(1.0 - (factor * factor), 0.0);

            float denom = max(distSqr, 1e4);
            vec3 Li = UINT_TO_VEC4(light.color_encoded).rgb * light.position_intensity.w;
            outLi += (smoothFactor * smoothFactor / denom) * Li;
        } else {
        }
    }

    return outLi;
}

// This function is used to debug the albedo color by tracing a ray onto the surface
// and returning the albedo color at that point.
vec3 DebugTest_Albedo(in vec3 position, in vec3 normal)
{
    // Save payload state
    vec4 saved_throughput = payload.throughput;
    vec4 saved_emissive = payload.emissive;
    float saved_distance = payload.distance;
    vec3 saved_normal = payload.normal;
    vec3 saved_bary = payload.barycentric_coords;
    uint saved_tri = payload.triangle_index;

    // Set up ray to hit the surface from a small offset
    vec3 origin = position + normal * 0.001;
    vec3 direction = -normal;

    // Reset payload for this trace
    payload.distance = -1.0;
    payload.throughput = vec4(0.0);
    payload.emissive = vec4(0.0);
    payload.triangle_index = ~0u;
    payload.normal = vec3(0.0);

    traceRayEXT(tlas, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, 0.0, direction, 1.0, 0);

    vec3 albedo = vec3(0.0);
    if (payload.distance >= 0.0) {
        albedo = payload.throughput.rgb;
    }

    // Restore payload
    payload.throughput = saved_throughput;
    payload.emissive = saved_emissive;
    payload.distance = saved_distance;
    payload.normal = saved_normal;
    payload.barycentric_coords = saved_bary;
    payload.triangle_index = saved_tri;

    return albedo;
}

void main()
{
    const uint ray_index = gl_LaunchIDEXT.x;

    LightmapRay ray;
    ray.origin = vec4(ray_data[ray_index * 2].xyz, 1.0);
    ray.direction = vec4(ray_data[ray_index * 2 + 1].xyz, 0.0);

    const uint flags = gl_RayFlagsOpaqueEXT;
    const uint mask = 0xff;
    const float tmin = 0.001;
    const float tmax = 1000.0;

    const vec3 N0 = normalize(ray.direction.xyz);

    vec3 tangent;
    vec3 bitangent;

    vec4 accumRadiance = vec4(0.0);

    uint ray_seed = InitRandomSeed(((rt_radiance_uniforms.ray_offset + ray_index) * 2), ((rt_radiance_uniforms.ray_offset + ray_index) * 2) + 1);

    for (uint sample_index = 0; sample_index < NUM_SAMPLES; sample_index++) {
        // initial direction: if IRRADIANCE -> random hemisphere about N0, else just N0
        vec3 direction;
#ifdef MODE_IRRADIANCE
        direction = normalize(RandomInHemisphere(vec3(RandomFloat(ray_seed), RandomFloat(ray_seed), RandomFloat(ray_seed)), N0));
#else
        direction = N0;
#endif
        vec3 origin = ray.origin.xyz + N0 * RAY_OFFSET;

        vec3 radiance = vec3(0.0);
        vec3 beta = vec3(1.0);

        for (int bounceIndex = 0; bounceIndex < NUM_BOUNCES; ++bounceIndex) {
            // perform scene trace using global payload
            payload.distance = -1.0;
            payload.throughput = vec4(1.0);
            payload.emissive = vec4(0.0);
            payload.triangle_index = ~0u;
            payload.normal = vec3(0.0);

            traceRayEXT(tlas, flags, mask, 0, 0, 0, origin, tmin, normalize(direction), tmax, 0);

            if (payload.distance < 0.0) {
                // miss -> sample environment probe if present
                if (current_env_probe.texture_index != ~0u) {
                    uint probe_texture_index = max(0, min(current_env_probe.texture_index, HYP_MAX_BOUND_REFLECTION_PROBES - 1));
                    vec3 env = Texture2D(sampler_linear, env_probe_textures[probe_texture_index], EncodeOctahedralCoord(normalize(direction)) * 0.5 + 0.5).rgb;
                    radiance += beta * env;
                }
                break;
            }

            vec3 albedo = clamp(payload.throughput.rgb, vec3(0.0), vec3(1.0));
            float metalness = payload.throughput.a;
            vec3 f = albedo * INV_PI * (1.0 - metalness);

            vec3 hitPos = origin + direction * payload.distance;
            vec3 N = normalize(payload.normal);

            // emissive
            if (length(payload.emissive.rgb) > 0.0) {
                radiance += beta * payload.emissive.rgb;
            }

            // add contributions from bound lights (with shadow handling for directional)
            radiance += beta * EvaluateDiffuseLighting(albedo, metalness, hitPos, N);

#ifndef MODE_IRRADIANCE
            // in radiance mode we only look up direct lights and stop
            break;
#else

            vec3 wi = normalize(RandomInHemisphere(vec3(RandomFloat(ray_seed), RandomFloat(ray_seed), RandomFloat(ray_seed)), N));
            float cosTheta = max(0.0, dot(N, wi));
            const float pdf = 1.0 / (2.0 * 3.14159265358979323846);

            beta *= f * (cosTheta / pdf);

            if (bounceIndex >= 2) {
                float p = clamp(max(max(beta.r, beta.g), beta.b), 0.05, 0.99);
                if (RandomFloat(ray_seed) > p) {
                    break;
                }
                beta /= p;
            }

            direction = wi;

            float sign = dot(N, direction) > 0.0 ? 1.0 : -1.0;
            origin = hitPos + N * (RAY_OFFSET * sign);
#endif
        } // end bounces

        accumRadiance.rgb += radiance;
    } // end samples

    vec3 finalColor = accumRadiance.rgb / float(NUM_SAMPLES);

    hits[ray_index] = vec4(finalColor, 1.0);
}
